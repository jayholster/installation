<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Living Mural · Minimal MVP</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: rgba(15, 23, 42, 0.9);
      --panel-border: rgba(148, 163, 184, 0.24);
      --text: #f8fafc;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.14);
      --success: #34d399;
      --warning: #fbbf24;
      --error: #f87171;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    *,
    *::before,
    *::after {


  <title>Living Prompt Mural · MVP</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --bg: #030712;
      --panel: rgba(10, 15, 30, 0.92);
      --panel-border: rgba(148, 163, 184, 0.14);
      --accent: #5eead4;
      --accent-soft: rgba(94, 234, 212, 0.2);
      --text: #f8fafc;
      --muted: #94a3b8;
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.4);

  <title>Living Prompt Mural MVP</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #03060d;
      --panel: rgba(11, 16, 28, 0.88);
      --panel-border: rgba(148, 163, 184, 0.18);
      --accent: #4bc0c8;
      --accent-soft: rgba(75, 192, 200, 0.2);
      --text: #f1f5f9;
      --muted: #94a3b8;
      --shadow: 0 24px 60px rgba(4, 9, 20, 0.45);

    }

    * {

      box-sizing: border-box;
    }

    body {
      margin: 0;

      min-height: 100vh;
      background: radial-gradient(circle at 18% 12%, rgba(56, 189, 248, 0.18), transparent 55%),
        radial-gradient(circle at 82% 18%, rgba(129, 140, 248, 0.12), transparent 60%),
        linear-gradient(165deg, #050b18 0%, #0b1220 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
    }

    .app {
      width: min(1100px, 100%);
      padding: clamp(20px, 3vw, 40px);
      display: flex;
      flex-direction: column;
      gap: clamp(24px, 3vw, 36px);
    }

    header {
      text-align: center;
      display: grid;
      gap: 12px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: -0.02em;
    }

    header p {
      margin: 0 auto;
      max-width: 620px;
      color: rgba(226, 232, 240, 0.88);
      line-height: 1.6;
      font-size: 1rem;
    }

    main {
      display: grid;
      gap: clamp(20px, 3vw, 32px);
    }

    @media (min-width: 960px) {
      main {
        grid-template-columns: minmax(420px, 1fr) minmax(320px, 360px);
        align-items: start;
      }
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 22px;
      box-shadow: 0 24px 48px rgba(5, 12, 24, 0.36);
      padding: clamp(20px, 3vw, 32px);
      display: grid;
      gap: 18px;
    }

    .panel h2,
    .panel h3 {
      margin: 0;
      letter-spacing: -0.01em;
    }

    .panel h2 {
      font-size: 1.4rem;
    }

    .panel h3 {
      font-size: 1.1rem;
      color: rgba(226, 232, 240, 0.92);
    }

    .mural-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .mural-header span {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .mural-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button,
    .button {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.2s ease;
      background: rgba(56, 189, 248, 0.16);
      color: var(--text);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.4);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.5);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    .button-secondary {
      background: rgba(148, 163, 184, 0.18);
    }

    .button-danger {
      background: rgba(248, 113, 113, 0.14);
    }

    .mural-canvas {
      border-radius: 18px;
      border: 1px dashed rgba(148, 163, 184, 0.32);
      background: radial-gradient(circle at 22% 18%, rgba(56, 189, 248, 0.15), transparent 55%),
        radial-gradient(circle at 78% 72%, rgba(14, 165, 233, 0.12), transparent 60%),
        rgba(15, 23, 42, 0.85);
      min-height: 360px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 18px;
      align-items: center;
      justify-items: center;
      padding: clamp(18px, 3vw, 26px);
      position: relative;
    }

    .mural-empty {
      color: rgba(148, 163, 184, 0.72);
      text-align: center;
      max-width: 340px;
      margin: 0;
    }

    .mural-tile {
      width: clamp(180px, 26vw, 260px);
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      text-align: center;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 20px;
      padding: 14px 14px 18px;
      box-shadow: 0 12px 30px rgba(6, 11, 22, 0.46);
      animation: pop-in 320ms ease;
    }

    .mural-tile.is-new {
      box-shadow: 0 16px 34px rgba(56, 189, 248, 0.22);
    }

    .mural-tile canvas {
      width: 100%;
      height: auto;
      display: block;
    }

    .tile-caption {
      display: grid;
      gap: 8px;
    }

    .caption-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
    }

    .tile-style {
      font-weight: 600;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .tile-meta {
      font-size: 0.78rem;
      color: rgba(226, 232, 240, 0.7);
    }

    .tile-prompt {
      margin: 0;
      font-size: 0.82rem;
      line-height: 1.4;
      color: rgba(203, 213, 225, 0.85);
    }

    .tile-prompt.empty {
      color: rgba(148, 163, 184, 0.75);
      font-style: italic;
    }

    @keyframes pop-in {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .controls {
      display: grid;
      gap: 18px;
    }

    fieldset {
      border: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 12px;
    }

    legend {
      font-weight: 600;
      letter-spacing: 0.02em;
      margin-bottom: 4px;
    }

    .style-options {
      display: grid;
      gap: 10px;
    }

    .style-option {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.26);
      background: rgba(15, 23, 42, 0.6);
      cursor: pointer;
      transition: border-color 0.2s ease, background-color 0.2s ease;
    }

    .style-option:hover {
      border-color: rgba(56, 189, 248, 0.45);
    }

    .style-option input {
      accent-color: var(--accent);
      width: 18px;
      height: 18px;
    }

    .style-description {
      display: grid;
      gap: 4px;
    }

    .style-description span:first-child {
      font-weight: 600;
    }

    label {
      font-weight: 600;
      letter-spacing: 0.01em;
      display: block;
    }

    textarea,
    select,
    input[type='file'],
    input[type='text'] {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      padding: 12px 14px;
      font-size: 0.95rem;
      font-family: inherit;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
    }

    input[type='file'] {
      padding: 10px;
    }

    .hint {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(148, 163, 184, 0.78);
    }

    .error {
      margin: 0;
      font-size: 0.85rem;
      color: var(--error);
    }

    .sample-prompts {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .sample-prompts button {
      background: rgba(56, 189, 248, 0.12);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.82rem;
      text-transform: none;
      letter-spacing: 0;
      font-weight: 500;
      border: 1px solid rgba(56, 189, 248, 0.28);
    }

    .sample-prompts button:hover {
      background: rgba(56, 189, 248, 0.2);
    }

    .preview-stage {
      border: 1px dashed rgba(148, 163, 184, 0.35);
      border-radius: 16px;
      padding: 20px;
      min-height: 220px;
      display: grid;
      place-items: center;
      background: rgba(15, 23, 42, 0.55);
      text-align: center;
      transition: border-color 0.2s ease, background-color 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .preview-stage.is-dragging {
      border-color: rgba(56, 189, 248, 0.55);
      background: rgba(15, 23, 42, 0.75);
    }

    .preview-stage.is-loading::after {
      content: 'Loading preview…';
      font-size: 0.85rem;
      color: rgba(148, 163, 184, 0.8);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .preview-stage img {
      max-width: 100%;
      max-height: 240px;
      border-radius: 14px;
      box-shadow: 0 12px 28px rgba(5, 12, 24, 0.42);
      display: none;
    }

    .preview-stage.ready img {
      display: block;
    }

    .preview-placeholder {
      color: rgba(148, 163, 184, 0.8);
      font-size: 0.9rem;
    }

    .preview-meta {
      display: grid;
      gap: 6px;

      font-family: 'Inter', sans-serif;

      background: radial-gradient(circle at 15% 20%, rgba(56, 189, 248, 0.2), transparent 55%),
        radial-gradient(circle at 75% 10%, rgba(196, 181, 253, 0.22), transparent 65%),
        linear-gradient(160deg, #020617 0%, #0f172a 100%);
      color: var(--text);

      color: var(--text);
      background: radial-gradient(circle at 20% 20%, rgba(35, 68, 120, 0.18), transparent 55%),
        radial-gradient(circle at 80% 10%, rgba(71, 44, 112, 0.24), transparent 60%),
        linear-gradient(160deg, #020511 0%, #0a1424 40%, #121a2b 100%);

      min-height: 100vh;
    }

    header {

      max-width: 1120px;
      margin: 0 auto;
      padding: 56px 24px 32px;
    }

    .hero {
      background: linear-gradient(135deg, rgba(17, 24, 39, 0.96), rgba(15, 23, 42, 0.88));
      border-radius: 28px;
      border: 1px solid rgba(148, 163, 184, 0.16);
      padding: 48px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 18% 25%, rgba(252, 211, 77, 0.28), transparent 55%),
        radial-gradient(circle at 82% 70%, rgba(94, 234, 212, 0.2), transparent 65%);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .hero h1 {
      margin: 0 0 12px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: clamp(2.4rem, 4vw, 3.6rem);
      letter-spacing: -0.02em;
    }

    .hero p {
      max-width: 620px;
      font-size: 1.05rem;
      line-height: 1.6;
      color: rgba(226, 232, 240, 0.85);
    }

    .badges {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 28px 0 32px;
    }

    .badge {
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.28);
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      text-transform: uppercase;
    }

    .hero .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      margin-top: 32px;
      align-items: center;
    }

    .cta {
      background: rgba(94, 234, 212, 0.18);
      border: 1px solid rgba(94, 234, 212, 0.5);
      color: var(--text);
      border-radius: 999px;
      padding: 12px 24px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: 0.86rem;
    }

    .palette-strip {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .palette-strip span {
      display: inline-flex;
      width: 24px;
      height: 24px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.14);
    }

    main {
      max-width: 1120px;
      margin: 0 auto;
      padding: 0 24px 96px;
      display: grid;
      gap: 40px;
    }

    section.panel {
      background: var(--panel);
      border-radius: 24px;
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      padding: 32px;
      position: relative;
      overflow: hidden;
    }

    section.panel h2 {
      margin: 0 0 16px;
      font-family: 'Space Grotesk', sans-serif;
      letter-spacing: -0.01em;
    }

    .layout-grid {
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      gap: 28px;
    }

    .lane-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 16px;
    }

    .lane-card {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 18px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
      min-height: 160px;
    }

    .lane-card.active {
      border-color: rgba(94, 234, 212, 0.7);
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(94, 234, 212, 0.18);
    }

    .lane-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .lane-card p {
      margin: 0;
      color: rgba(226, 232, 240, 0.75);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    .lane-card ul {
      margin: 0;
      padding-left: 18px;
      color: rgba(226, 232, 240, 0.75);
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .studio-controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    label span {
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      color: var(--muted);
      text-transform: uppercase;
    }

    textarea,
    input,
    select,
    button {
      font-family: inherit;
    }

    textarea,
    input,
    select {
      width: 100%;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(10, 17, 35, 0.8);
      color: var(--text);
      font-size: 0.95rem;
    }

    textarea:focus,
    input:focus,
    select:focus {
      outline: 2px solid rgba(94, 234, 212, 0.4);
      border-color: transparent;
    }

    button {
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid transparent;
      font-weight: 600;
      cursor: pointer;
      background: rgba(94, 234, 212, 0.2);
      color: var(--text);
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.8);
      border-color: rgba(148, 163, 184, 0.3);
    }

    button[disabled] {
      opacity: 0.5;
      pointer-events: none;
    }

    .upload-zone {
      border: 2px dashed rgba(148, 163, 184, 0.28);
      border-radius: 16px;
      padding: 24px;
      text-align: center;
      color: rgba(226, 232, 240, 0.75);
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .upload-zone.dragover {
      border-color: rgba(94, 234, 212, 0.8);
      background: rgba(94, 234, 212, 0.06);
    }

    .upload-queue {
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(10, 17, 35, 0.7);
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.2);
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .queue-item.active {
      border-color: rgba(94, 234, 212, 0.7);
    }

    .queue-thumb {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.8);
      overflow: hidden;
      display: grid;
      place-items: center;
    }

    .queue-thumb canvas,
    .queue-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .queue-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .queue-meta span {
      font-size: 0.9rem;
    }

    .queue-meta small {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .sample-card {
      display: flex;
      gap: 16px;
      padding: 16px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.7);
      align-items: center;
    }

    .sample-meta {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 0.9rem;
      color: rgba(226, 232, 240, 0.8);
    }

    .preview-wrap {
      display: grid;
      grid-template-columns: minmax(320px, 480px) minmax(280px, 1fr);
      gap: 24px;
      align-items: start;
    }

    #previewCanvas,
    #sampleCanvas {
      width: 100%;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.24);
      background: rgba(15, 23, 42, 0.9);

    }

    .preview-actions {
      display: flex;

      gap: 10px;
      flex-wrap: wrap;
    }

    .feather-control {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 0.88rem;
      color: rgba(203, 213, 225, 0.9);
    }

    .feather-control input[type='range'] {
      flex: 1;
      accent-color: var(--accent);
    }

    .style-note {
      margin: 0;
      font-size: 0.88rem;
      color: rgba(203, 213, 225, 0.92);
    }

    .style-note strong {
      color: rgba(248, 250, 252, 0.92);
    }

    footer {
      text-align: center;
      font-size: 0.82rem;
      color: rgba(148, 163, 184, 0.7);
      padding-bottom: 16px;
    }

    .mural-tile[data-style='impasto'] .tile-style {
      color: #fbbf24;
    }

    .mural-tile[data-style='cartoon'] .tile-style {
      color: #38bdf8;
    }

    .mural-tile[data-style='ink'] .tile-style {
      color: #a855f7;
    }

    .mural-tile[data-style='collage'] .tile-style {
      color: #f97316;
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Living Prompt Mural</h1>
      <p>
        A minimal working prototype: drop in what you made with Midjourney, Sora, or your camera, soften the edges, and place
        it into a shared mural. Every control below works so the board can feel the flow.
      </p>
    </header>
    <main>
      <section class="panel" aria-labelledby="mural-title">
        <div class="mural-header">
          <div>
            <h2 id="mural-title">Mural in Progress</h2>
            <span id="tileCount" aria-live="polite">0 tiles</span>
          </div>
          <div class="mural-actions">
            <button class="button-secondary" type="button" id="shuffleLayout" disabled>Shuffle</button>
            <button class="button-danger" type="button" id="clearMural">Clear mural</button>
          </div>
        </div>
        <div id="muralCanvas" class="mural-canvas" aria-live="polite">
          <p id="muralEmptyState" class="mural-empty">Add images from the studio to see the mural blend together.</p>
        </div>
        <p class="feather-control">
          <span>Edge feather</span>
          <input id="featherRange" type="range" min="0" max="80" value="28" />
          <span id="featherValue">28 px</span>
        </p>
      </section>
      <section class="panel controls" aria-labelledby="studio-title">
        <h2 id="studio-title">Studio Controls</h2>
        <fieldset>
          <legend>Choose a style lane</legend>
          <div class="style-options">
            <label class="style-option">
              <input type="radio" name="styleLane" value="impasto" checked />
              <div class="style-description">
                <span>Impasto Paint World</span>
                <span class="hint">Thick brushstrokes, golden side light, living texture.</span>
              </div>
            </label>
            <label class="style-option">
              <input type="radio" name="styleLane" value="cartoon" />
              <div class="style-description">
                <span>Cartoon Storyboard</span>
                <span class="hint">Bold outlines, playful motion, color-block energy.</span>
              </div>
            </label>
            <label class="style-option">
              <input type="radio" name="styleLane" value="ink" />
              <div class="style-description">
                <span>Ink &amp; Wash</span>
                <span class="hint">Loose washes, gentle gradients, poetic line.</span>
              </div>
            </label>
            <label class="style-option">
              <input type="radio" name="styleLane" value="collage" />
              <div class="style-description">
                <span>Collage Reverie</span>
                <span class="hint">Cut-paper textures, layered ephemera, warm grain.</span>
              </div>
            </label>
          </div>
        </fieldset>
        <p id="styleSummary" class="style-note"></p>
        <div>
          <label for="promptInput">Prompt notes for the wall label</label>
          <textarea id="promptInput" placeholder="Describe the feeling, materials, or story behind your piece."></textarea>
          <div class="sample-prompts" id="samplePrompts" aria-live="polite"></div>
        </div>
        <div>
          <label for="fileInput">Upload images (PNG, JPG — up to 10 MB each)</label>
          <input id="fileInput" type="file" accept="image/*" multiple />
          <p class="hint">Queue: <span id="queueCount">0</span> waiting</p>
          <p id="uploadFeedback" class="hint" aria-live="polite"></p>
          <p id="uploadError" class="error" role="status" aria-live="assertive"></p>
        </div>
        <div>
          <h3>Preview</h3>
          <div id="previewStage" class="preview-stage" role="region" aria-live="polite">
            <img id="previewImage" alt="Current preview" />
            <p id="previewPlaceholder" class="preview-placeholder">
              Drop an image here or use the upload button to start.
            </p>
          </div>
          <div class="preview-meta">
            <p id="previewInfo" class="hint">No image in review.</p>
            <p id="previewNotes" class="hint">Prompt notes appear here once you add them.</p>
          </div>
          <div class="preview-actions">
            <button class="button-secondary" type="button" id="skipButton" disabled>Skip / next</button>
            <button type="button" id="keepButton" disabled>Add to mural</button>
          </div>
        </div>
      </section>
    </main>
    <footer>
      This single HTML file keeps everything client-side for review. Uploads stay in your browser while we demo the flow.
    </footer>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const STYLE_LANES = {
        impasto: {
          label: 'Impasto Paint World',
          summary: 'Lean into thick paint, side-light, and saturated warmth.',
          samples: [
            'Thick oil impasto of twilight rooftops glowing with orange rim light',
            'Palette knife portrait lit by stained glass reflection',
            'Golden hour wet-on-wet brushwork of a community garden in bloom'
          ]
        },
        cartoon: {
          label: 'Cartoon Storyboard',
          summary: 'High contrast characters, motion lines, and playful blocking.',
          samples: [
            'Dynamic cartoon friends planting trees with exaggerated motion lines',
            'Bold storyboard frame of kids remixing a mural, comic halftones',
            'Saturday morning style hero pose celebrating community care'
          ]
        },
        ink: {
          label: 'Ink & Wash',
          summary: 'Atmospheric washes, delicate line work, and quiet gradients.',
          samples: [
            'Loose ink wash of a rainy city street reflecting neon puddles',
            'Brush and ink portrait with soft shadow wash and handwritten notes',
            'Monochrome landscape with drifting clouds and layered mountains'
          ]
        },
        collage: {
          label: 'Collage Reverie',
          summary: 'Layered paper, zine textures, and overlapping ephemera.',
          samples: [
            'Analog collage of archival photos layered with handmade paper textures',
            'Cut-paper dreamscape mixing flora, community portraits, and fabric',
            'Mixed-media collage with typography celebrating mutual aid stories'
          ]
        }
      };

      const state = {
        currentStyle: 'impasto',
        queue: [],
        preview: null,
        tiles: [],
        feather: 28
      };

      const elements = {
        styleRadios: document.querySelectorAll("input[name='styleLane']"),
        styleSummary: document.getElementById('styleSummary'),
        samplePrompts: document.getElementById('samplePrompts'),
        promptInput: document.getElementById('promptInput'),
        fileInput: document.getElementById('fileInput'),
        queueCount: document.getElementById('queueCount'),
        uploadFeedback: document.getElementById('uploadFeedback'),
        uploadError: document.getElementById('uploadError'),
        previewStage: document.getElementById('previewStage'),
        previewImage: document.getElementById('previewImage'),
        previewPlaceholder: document.getElementById('previewPlaceholder'),
        previewInfo: document.getElementById('previewInfo'),
        previewNotes: document.getElementById('previewNotes'),
        keepButton: document.getElementById('keepButton'),
        skipButton: document.getElementById('skipButton'),
        mural: document.getElementById('muralCanvas'),
        muralEmpty: document.getElementById('muralEmptyState'),
        tileCount: document.getElementById('tileCount'),
        clearButton: document.getElementById('clearMural'),
        shuffleButton: document.getElementById('shuffleLayout'),
        featherRange: document.getElementById('featherRange'),
        featherValue: document.getElementById('featherValue')
      };

      const MAX_FILE_SIZE = 10 * 1024 * 1024;
      const MAX_TILE_DIMENSION = 420;
      let redrawTimer = null;

      function init() {
        elements.styleRadios.forEach((radio) => {
          radio.addEventListener('change', () => {
            if (radio.checked) {
              selectStyle(radio.value);
            }
          });
        });

        elements.promptInput.addEventListener('input', () => {
          updatePreviewNotes(elements.promptInput.value.trim());
        });

        elements.fileInput.addEventListener('change', (event) => {
          const files = Array.from(event.target.files || []);
          ingestFiles(files);
          event.target.value = '';
        });

        elements.previewStage.addEventListener('dragover', (event) => {
          event.preventDefault();
          elements.previewStage.classList.add('is-dragging');
        });

        elements.previewStage.addEventListener('dragleave', () => {
          elements.previewStage.classList.remove('is-dragging');
        });

        elements.previewStage.addEventListener('drop', (event) => {
          event.preventDefault();
          elements.previewStage.classList.remove('is-dragging');
          const files = Array.from(event.dataTransfer?.files || []);
          ingestFiles(files);
        });

        elements.keepButton.addEventListener('click', addPreviewToMural);
        elements.skipButton.addEventListener('click', () => {
          skipPreview();
        });
        elements.clearButton.addEventListener('click', clearMural);
        elements.shuffleButton.addEventListener('click', shuffleMural);

        elements.previewImage.addEventListener('load', () => {
          if (!state.preview) return;
          if (elements.previewImage.src !== state.preview.dataUrl) {
            return;
          }
          state.preview.width = elements.previewImage.naturalWidth;
          state.preview.height = elements.previewImage.naturalHeight;
          updatePreviewInfo();
        });

        elements.featherRange.addEventListener('input', (event) => {
          const value = Number(event.target.value);
          state.feather = value;
          elements.featherValue.textContent = `${value} px`;
          scheduleRedraw();
        });

        selectStyle(state.currentStyle);
        updatePreviewUI();
        updateQueueCount();
        updatePreviewNotes('');
      }

      function selectStyle(styleId) {
        state.currentStyle = styleId;
        const style = STYLE_LANES[styleId];
        if (!style) return;
        elements.styleSummary.innerHTML = `<strong>${style.label}:</strong> ${style.summary}`;
        renderSamplePrompts(style.samples || []);
        if (state.preview) {
          state.preview.styleId = styleId;
          updatePreviewInfo();
        }
      }

      function renderSamplePrompts(samples) {
        elements.samplePrompts.innerHTML = '';
        samples.forEach((sample) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.textContent = sample;
          button.addEventListener('click', () => {
            elements.promptInput.value = sample;
            updatePreviewNotes(sample);
          });
          elements.samplePrompts.appendChild(button);
        });
      }

      function ingestFiles(files) {
        if (!files.length) return;
        let accepted = 0;
        const errors = [];
        files.forEach((file) => {
          if (!file.type.startsWith('image/')) {
            errors.push(`Skipped ${file.name} (not an image).`);
            return;
          }
          if (file.size > MAX_FILE_SIZE) {
            errors.push(`Skipped ${file.name} (over 10 MB).`);
            return;
          }
          state.queue.push(file);
          accepted += 1;
        });

        if (accepted) {
          elements.uploadFeedback.textContent = `Added ${accepted} image${accepted === 1 ? '' : 's'} to the queue.`;
          if (!state.preview) {
            loadNextFromQueue();
          } else {
            updatePreviewUI();
          }
        } else {
          elements.uploadFeedback.textContent = '';
        }
        elements.uploadError.textContent = errors.join(' ');
        updateQueueCount();
      }

      function loadNextFromQueue() {
        if (!state.queue.length) {
          state.preview = null;
          updatePreviewUI();
          return;
        }
        const file = state.queue.shift();
        updateQueueCount();
        const preview = {
          file,
          dataUrl: null,
          styleId: state.currentStyle,
          prompt: elements.promptInput.value.trim(),
          width: null,
          height: null
        };
        state.preview = preview;
        updatePreviewUI();
        const reader = new FileReader();
        reader.onload = (event) => {
          if (state.preview !== preview) {
            return;
          }
          preview.dataUrl = event.target?.result || null;
          updatePreviewUI();
        };
        reader.onerror = () => {
          if (state.preview === preview) {
            elements.uploadError.textContent = `Could not read ${file.name}.`;
            state.preview = null;
            updatePreviewUI();
          }
          loadNextFromQueue();
        };
        reader.readAsDataURL(file);
      }

      function updateQueueCount() {
        elements.queueCount.textContent = state.queue.length;
      }

      function formatDimensions(width, height) {
        return width > 0 && height > 0 ? `${width} × ${height}px` : '—';
      }

      function truncate(text, maxLength) {
        if (!text) return '';
        const clean = `${text}`.trim();
        return clean.length > maxLength ? `${clean.slice(0, Math.max(0, maxLength - 1))}…` : clean;
      }

      function updatePreviewUI() {
        const preview = state.preview;
        elements.previewStage.classList.remove('is-loading', 'ready');
        if (!preview) {
          elements.previewPlaceholder.textContent = 'Drop an image here or use the upload button to start.';
          elements.previewImage.src = '';
          elements.previewImage.style.display = 'none';
          elements.previewPlaceholder.style.display = 'block';
        } else if (!preview.dataUrl) {
          elements.previewStage.classList.add('is-loading');
          elements.previewPlaceholder.textContent = `Loading ${preview.file.name}…`;
          elements.previewImage.src = '';
          elements.previewImage.style.display = 'none';
          elements.previewPlaceholder.style.display = 'block';
        } else {
          elements.previewStage.classList.add('ready');
          elements.previewPlaceholder.textContent = '';
          if (elements.previewImage.src !== preview.dataUrl) {
            elements.previewImage.src = preview.dataUrl;
          }
          elements.previewImage.style.display = 'block';
          elements.previewPlaceholder.style.display = 'none';
        }
        updatePreviewInfo();
        refreshControls();
      }

      function updatePreviewInfo() {
        const preview = state.preview;
        if (!preview) {
          elements.previewInfo.textContent = 'No image in review.';
          updatePreviewNotes(elements.promptInput.value.trim());
          return;
        }
        const style = STYLE_LANES[preview.styleId] || { label: 'Unknown style' };
        const sizeMb = (preview.file.size / (1024 * 1024)).toFixed(2);
        const dimensions = preview.width && preview.height ? `${preview.width} × ${preview.height}px` : 'Loading size…';
        elements.previewInfo.textContent = `${style.label} • ${dimensions} • ${sizeMb} MB`;
        updatePreviewNotes(preview.prompt || elements.promptInput.value.trim());
      }

      function updatePreviewNotes(notes) {
        const text = notes?.trim() || '';
        if (state.preview) {
          state.preview.prompt = text;
        }
        elements.previewNotes.textContent = text ? `Notes: “${text}”` : 'Prompt notes appear here once you add them.';
      }

      function refreshControls() {
        elements.keepButton.disabled = !(state.preview && state.preview.dataUrl);
        elements.skipButton.disabled = !state.preview && state.queue.length === 0;
        elements.shuffleButton.disabled = state.tiles.length < 2;
      }

      function addPreviewToMural() {
        const preview = state.preview;
        if (!preview || !preview.dataUrl) {
          return;
        }
        elements.keepButton.disabled = true;
        const tile = document.createElement('figure');
        tile.className = 'mural-tile';
        tile.dataset.style = preview.styleId;
        tile.tabIndex = 0;

        const canvas = document.createElement('canvas');
        canvas.className = 'tile-canvas';
        canvas.setAttribute('aria-hidden', 'true');

        const caption = document.createElement('figcaption');
        caption.className = 'tile-caption';

        const head = document.createElement('div');
        head.className = 'caption-head';
        const styleSpan = document.createElement('span');
        styleSpan.className = 'tile-style';
        styleSpan.textContent = STYLE_LANES[preview.styleId]?.label || 'Selected style';
        const metaSpan = document.createElement('span');
        metaSpan.className = 'tile-meta';
        metaSpan.textContent =
          preview.width && preview.height ? `${preview.width} × ${preview.height}px` : 'Rendering…';
        head.append(styleSpan, metaSpan);

        const promptP = document.createElement('p');
        promptP.className = 'tile-prompt';
        if (preview.prompt) {
          const trimmedPrompt = preview.prompt.trim();
          const summary = truncate(trimmedPrompt, 140);
          promptP.textContent = `“${summary}”`;
          if (summary.length < trimmedPrompt.length) {
            promptP.title = trimmedPrompt;
          }
        } else {
          promptP.textContent = 'Add prompt notes to tell this story.';
          promptP.classList.add('empty');
        }

        caption.append(head, promptP);
        tile.append(canvas, caption);
        elements.mural.appendChild(tile);
        elements.muralEmpty.hidden = true;

        const tileRecord = {
          dataUrl: preview.dataUrl,
          canvas,
          metaSpan,
          prompt: preview.prompt,
          styleId: preview.styleId,
          originalWidth: preview.width,
          originalHeight: preview.height
        };
        state.tiles.push(tileRecord);
        updateTileCount();
        refreshControls();

        drawBlendedCanvas(canvas, preview.dataUrl, state.feather).then(({ width, height }) => {
          const ariaPrompt = truncate(preview.prompt, 160);
          metaSpan.textContent = formatDimensions(width, height);
          tile.setAttribute(
            'aria-label',
            `${STYLE_LANES[preview.styleId]?.label || 'Tile'}${ariaPrompt ? `, prompt: ${ariaPrompt}` : ''}`
          );
        });

        tile.classList.add('is-new');
        setTimeout(() => tile.classList.remove('is-new'), 600);
        if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          tile.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
        }

        state.preview = null;
        updatePreviewUI();
        loadNextFromQueue();
      }

      function drawBlendedCanvas(canvas, dataUrl, feather) {
        return new Promise((resolve) => {
          if (!dataUrl) {
            resolve({ width: 0, height: 0 });
            return;
          }
          const image = new Image();
          image.onload = () => {
            const context = canvas.getContext('2d');
            if (!context) {
              resolve({ width: 0, height: 0 });
              return;
            }
            const scale = Math.min(1, MAX_TILE_DIMENSION / Math.max(image.width, image.height));
            const width = Math.max(1, Math.round(image.width * scale));
            const height = Math.max(1, Math.round(image.height * scale));
            canvas.width = width;
            canvas.height = height;
            context.clearRect(0, 0, width, height);
            context.globalCompositeOperation = 'source-over';
            context.drawImage(image, 0, 0, width, height);
            const featherPx = Math.max(0, Math.min(feather, Math.max(width, height) / 1.5));
            if (featherPx > 0) {
              const maxRadius = Math.sqrt(width * width + height * height) / 2;
              const innerRadius = Math.max(0, maxRadius - featherPx);
              const gradient = context.createRadialGradient(
                width / 2,
                height / 2,
                innerRadius,
                width / 2,
                height / 2,
                maxRadius
              );
              gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
              gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
              context.globalCompositeOperation = 'destination-in';
              context.fillStyle = gradient;
              context.fillRect(0, 0, width, height);
              context.globalCompositeOperation = 'source-over';
            }
            resolve({ width, height });
          };
          image.onerror = () => {
            resolve({ width: 0, height: 0 });
          };
          image.src = dataUrl;
        });
      }

      function skipPreview() {
        state.preview = null;
        updatePreviewUI();
        loadNextFromQueue();
      }

      function clearMural() {
        state.tiles = [];
        elements.mural.querySelectorAll('.mural-tile').forEach((tile) => tile.remove());
        elements.muralEmpty.hidden = false;
        updateTileCount();
        refreshControls();
      }

      function shuffleMural() {
        if (state.tiles.length < 2) return;
        const tiles = Array.from(elements.mural.querySelectorAll('.mural-tile'));
        tiles.sort(() => Math.random() - 0.5);
        tiles.forEach((tile) => elements.mural.appendChild(tile));
        state.tiles.sort(() => Math.random() - 0.5);
      }

      function scheduleRedraw() {
        if (!state.tiles.length) return;
        if (redrawTimer) {
          window.clearTimeout(redrawTimer);
        }
        redrawTimer = window.setTimeout(() => {
          state.tiles.forEach((tile) => {
            drawBlendedCanvas(tile.canvas, tile.dataUrl, state.feather).then(({ width, height }) => {
              tile.metaSpan.textContent = formatDimensions(width, height);
            });
          });
        }, 120);
      }

      function updateTileCount() {
        const count = state.tiles.length;
        elements.tileCount.textContent = count === 1 ? '1 tile' : `${count} tiles`;
        elements.shuffleButton.disabled = count < 2;
      }

      init();
    });

      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    #statusBar,
    #timelapseStatus {
      font-size: 0.85rem;
      color: var(--muted);
    }

    form#metadataForm {
      display: grid;
      gap: 16px;
    }

    .consent-line {
      display: flex;
      gap: 12px;
      align-items: start;
      font-size: 0.82rem;
      line-height: 1.4;
      color: rgba(226, 232, 240, 0.75);
    }

    .mural-wrapper {
      position: relative;
      border-radius: 24px;
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    #muralCanvas {
      display: block;
      width: 100%;
      height: auto;
      background: radial-gradient(circle at 30% 20%, rgba(30, 64, 175, 0.3), transparent 60%),
        radial-gradient(circle at 70% 70%, rgba(56, 189, 248, 0.2), transparent 65%),
        rgba(2, 6, 23, 0.9);
    }

    #tileTooltip {
      position: absolute;
      padding: 12px 14px;
      background: rgba(15, 23, 42, 0.9);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      font-size: 0.8rem;
      line-height: 1.4;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      max-width: 220px;
      backdrop-filter: blur(6px);
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 18px;
    }

    .pill {
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.25);
      font-size: 0.78rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .audio-board {
      display: grid;
      gap: 12px;
      margin-top: 18px;
    }

    .audio-card {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.75);
    }

    .audio-card button {
      padding: 8px 14px;
      font-size: 0.82rem;
    }

    #timelapseDisplay {
      min-height: 180px;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.24);
      background: rgba(15, 23, 42, 0.7);
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    #timelapseDisplay img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
    }

    .micro-module {
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.24);
      padding: 18px;
      background: rgba(15, 23, 42, 0.78);
    }

    .micro-module h3 {
      margin: 0 0 12px;
      font-size: 1rem;
    }

    .micro-module ul {
      margin: 0;
      padding-left: 18px;
      font-size: 0.88rem;
      line-height: 1.5;
      color: rgba(226, 232, 240, 0.8);
    }

    .reflection-list {
      margin: 0;
      padding-left: 18px;
      color: rgba(226, 232, 240, 0.78);
      line-height: 1.5;
    }

    footer {
      max-width: 1120px;
      margin: 0 auto;
      padding: 0 24px 60px;
      font-size: 0.82rem;
      color: var(--muted);
    }

    @media (max-width: 960px) {
      .layout-grid,
      .preview-wrap {
        grid-template-columns: 1fr;
      }

      header {
        padding: 40px 20px 24px;
      }

      .hero {
        padding: 36px;
      }
    }

    @media (max-width: 640px) {
      main {
        padding-bottom: 72px;
      }

      .hero {
        padding: 28px;
      }

      .hero h1 {
        font-size: clamp(2rem, 8vw, 2.8rem);

      max-width: 1200px;
      margin: 0 auto;
      padding: 56px 24px 32px;
    }

    .hero {
      background: linear-gradient(135deg, rgba(28, 37, 54, 0.92), rgba(13, 20, 34, 0.92)),
        url('https://images.unsplash.com/photo-1513364776144-60967b0f800f?auto=format&fit=crop&w=1600&q=80') center/cover;
      border-radius: 28px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 48px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .hero::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 15% 20%, rgba(255, 188, 66, 0.28), transparent 55%),
        radial-gradient(circle at 80% 70%, rgba(75, 192, 200, 0.2), transparent 60%);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .hero h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 700;
      font-size: clamp(2.4rem, 3.8vw, 3.6rem);
      margin-bottom: 16px;
      letter-spacing: -0.02em;
    }

    .hero p {
      max-width: 600px;
      font-size: 1.05rem;
      line-height: 1.6;
      color: rgba(226, 232, 240, 0.85);
    }

    .hero .badges {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 32px 0;
    }

    .badge {
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.32);
      padding: 10px 16px;
      border-radius: 999px;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .hero .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 40px;
      align-items: center;
    }

    .hero .cta {
      background: rgba(75, 192, 200, 0.15);
      border: 1px solid rgba(75, 192, 200, 0.5);
      color: #e0faff;
      border-radius: 999px;
      padding: 12px 24px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.86rem;
    }

    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 24px 96px;
      display: grid;
      gap: 48px;
    }

    section.panel {
      background: var(--panel);
      border-radius: 24px;
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      padding: 32px;
      position: relative;
      overflow: hidden;
    }

    section.panel h2 {
      margin-top: 0;
      margin-bottom: 16px;
      font-family: 'Space Grotesk', sans-serif;
      letter-spacing: -0.01em;
    }

    .layout-grid {
      display: grid;
      gap: 32px;
    }

    .lane-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .lane-card {
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.32);
      border-radius: 20px;
      padding: 20px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: transform 0.25s ease, border-color 0.25s ease, background 0.25s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .lane-card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), transparent 50%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .lane-card:hover::after,
    .lane-card.active::after {
      opacity: 1;
    }

    .lane-card.active {
      transform: translateY(-6px);
      border-color: rgba(79, 209, 197, 0.65);
      background: rgba(39, 55, 90, 0.78);
    }

    .lane-card h3 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.01em;
    }

    .lane-card .accent-dot {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      margin-bottom: 6px;
      border: 2px solid rgba(255, 255, 255, 0.25);
    }

    .lane-card ul {
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 0.88rem;
      line-height: 1.5;
    }

    .studio-controls {
      display: grid;
      gap: 24px;
    }

    .field {
      display: grid;
      gap: 8px;
    }

    label span {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(226, 232, 240, 0.6);
    }

    textarea,
    input[type="text"],
    select {
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.24);
      color: var(--text);
      font: inherit;
      padding: 12px 14px;
      border-radius: 14px;
      min-height: 52px;
      resize: vertical;
    }

    textarea::placeholder,
    input::placeholder {
      color: rgba(148, 163, 184, 0.55);
    }

    .upload-zone {
      border: 1.5px dashed rgba(148, 163, 184, 0.45);
      border-radius: 18px;
      padding: 24px;
      display: grid;
      gap: 12px;
      place-items: center;
      text-align: center;
      color: rgba(226, 232, 240, 0.75);
      transition: border-color 0.25s ease, background 0.25s ease;
    }

    .upload-zone.dragging {
      border-color: rgba(79, 209, 197, 0.65);
      background: rgba(24, 42, 64, 0.55);
    }

    .upload-zone button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 10px 20px;
      background: rgba(15, 23, 42, 0.6);
      color: var(--text);
      font-weight: 500;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease;
    }

    .upload-zone button:hover {
      transform: translateY(-2px);
      border-color: rgba(79, 209, 197, 0.75);
    }

    .preview-wrap {
      display: grid;
      gap: 16px;
    }

    canvas#previewCanvas {
      width: 100%;
      max-width: 560px;
      height: 320px;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: radial-gradient(circle at top left, rgba(79, 209, 197, 0.18), transparent 65%),
        rgba(10, 14, 22, 0.9);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    .preview-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    button.primary {
      background: linear-gradient(135deg, rgba(75, 192, 200, 0.9), rgba(59, 96, 228, 0.9));
      border: none;
      padding: 12px 24px;
      border-radius: 14px;
      color: #021522;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(75, 192, 200, 0.35);
      transition: transform 0.22s ease;
    }

    button.primary:hover {
      transform: translateY(-2px);
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.32);
      color: var(--text);
      padding: 12px 20px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 500;
      letter-spacing: 0.02em;
    }

    button.secondary:hover {
      border-color: rgba(79, 209, 197, 0.65);
    }

    form#metadataForm {
      display: none;
      border-top: 1px solid rgba(148, 163, 184, 0.18);
      padding-top: 18px;
      margin-top: 6px;
      gap: 18px;
    }

    form#metadataForm.visible {
      display: grid;
    }

    .consent-line {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: rgba(226, 232, 240, 0.75);
    }

    .consent-line input {
      margin-top: 4px;
    }

    #statusBar {
      min-height: 32px;
      font-size: 0.9rem;
      color: rgba(148, 163, 184, 0.88);
    }

    #muralWrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      background: radial-gradient(circle at 25% 25%, rgba(79, 209, 197, 0.08), transparent 58%),
        radial-gradient(circle at 75% 70%, rgba(59, 96, 228, 0.12), transparent 55%),
        rgba(7, 11, 20, 0.92);
    }

    canvas#muralCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #tileTooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 0.8rem;
      line-height: 1.4;
      color: rgba(226, 232, 240, 0.9);
      min-width: 160px;
      z-index: 20;
      opacity: 0;
      transform: translate(-50%, -50%);
      transition: opacity 0.15s ease;
    }

    #tileTooltip strong {
      color: #f9d776;
      font-weight: 600;
    }

    .mural-meta {
      display: grid;
      gap: 18px;
      margin-top: 24px;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .pill {
      padding: 8px 14px;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.32);
      font-size: 0.82rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .palette-sample {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .swatch {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    }

    .audio-board {
      display: grid;
      gap: 14px;
    }

    .audio-item {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.62);
      border: 1px solid rgba(148, 163, 184, 0.24);
      border-radius: 14px;
    }

    .audio-item button {
      background: rgba(79, 209, 197, 0.18);
      border: 1px solid rgba(79, 209, 197, 0.55);
      color: #e0faff;
      border-radius: 10px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 0.78rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    #timelapseDisplay {
      display: grid;
      place-items: center;
      min-height: 200px;
      border: 1px dashed rgba(148, 163, 184, 0.32);
      border-radius: 16px;
      overflow: hidden;
    }

    #timelapseDisplay img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .grid-two {
      display: grid;
      gap: 28px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .micro-module {
      background: rgba(15, 23, 42, 0.68);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 18px;
      padding: 18px;
      display: grid;
      gap: 10px;
    }

    .micro-module h3 {
      margin: 0;
      font-size: 1.05rem;
      letter-spacing: 0.01em;
    }

    .micro-module ul {
      margin: 0;
      padding-left: 18px;
      color: rgba(226, 232, 240, 0.75);
      font-size: 0.9rem;
      line-height: 1.55;
    }

    footer {
      max-width: 1200px;
      margin: 24px auto 40px;
      padding: 0 24px;
      color: rgba(148, 163, 184, 0.7);
      font-size: 0.82rem;
      letter-spacing: 0.04em;
    }

    @media (max-width: 960px) {
      .hero {
        padding: 36px;
      }

      section.panel {
        padding: 24px;
      }
    }

    @media (max-width: 720px) {
      header {
        padding: 36px 18px 18px;
      }

      main {
        padding: 0 18px 72px;
      }

      canvas#previewCanvas {
        height: 260px;
      }

      .preview-actions {
        flex-direction: column;
        align-items: stretch;
      }

      button.primary,
      button.secondary {
        width: 100%;

      }
    }
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <h1>Living Prompt Mural MVP</h1>
      <p>

        A people-first studio where artists test prompts, soften edges, and submit blended tiles for a collective mural.
        Built for the board demo—fast, cohesive, and grounded in consent.
      </p>
      <div class="badges">
        <span class="badge">Prompt ➝ Preview ➝ Submit</span>
        <span class="badge">Edge-Blended Moodboard</span>
        <span class="badge">Audio-Reactive Flow</span>
        <span class="badge">Literacy &amp; Consent</span>
      </div>
      <div class="cta-row">
        <span class="cta">Palette in play: <strong id="paletteName">Aurora Brush Relay</strong></span>
        <div class="palette-strip" id="paletteStrip"></div>

       This is a prototype that shows how creators can move from prompt to preview to a blended, audio-reactive
        mural. Everything here runs in a single HTML file you can open from GitHub Pages, making it easy to demo the flow
        with no backend.
      </p>
      <div class="badges">
        <span class="badge">Prompt ➝ Preview ➝ Submit Flow</span>
        <span class="badge">Edge-Blended Tiles</span>
        <span class="badge">Audio-Reactive Animation</span>
        <span class="badge">Micro-Lessons on Prompting</span>
      </div>
      <div class="cta-row">
        <span class="cta">Global Palette: <strong id="paletteName">Aurora Brush Relay</strong></span>
        <div class="palette-sample" id="paletteSwatches"></div>

      </div>
    </div>
  </header>
  <main>

    <section class="panel" id="studioSection">
      <h2>Studio · choose a lane</h2>
      <div class="layout-grid">
        <div class="lane-grid" id="laneGrid"></div>
        <div class="studio-controls">
          <div>
            <label for="promptInput"><span>Prompt note</span></label>
            <textarea id="promptInput" rows="3" placeholder="Name the material, light, and feeling you want to carry."></textarea>
          </div>
          <div>
            <label><span>Upload image (drag &amp; drop)</span></label>
            <div class="upload-zone" id="uploadZone">
              <input type="file" id="imageInput" accept="image/*" multiple hidden />
              <p>Drop Midjourney, Sora, or phone captures. Up to 10MB each. Queue handles batches.</p>
              <button type="button" id="browseButton">Browse files</button>
              <small>Queue count: <span id="queueCount">0</span></small>
            </div>
            <div class="upload-queue" id="queueList" hidden></div>
          </div>
          <div>
            <label><span>Lane example</span></label>
            <div class="sample-card">
              <canvas id="sampleCanvas" width="120" height="120" aria-hidden="true"></canvas>
              <div class="sample-meta">
                <p id="samplePrompt">Pick a lane to load a prompt starter.</p>
                <div class="preview-actions">
                  <button type="button" id="refreshSample">New example</button>
                  <button type="button" id="useSample" class="secondary">Use prompt</button>
                </div>
              </div>
            </div>
          </div>
          <div>
            <label><span>Attach soundtrack (optional)</span></label>
            <input type="file" id="audioInput" accept="audio/*" />
            <small style="color: var(--muted);">Udio / Suno uploads welcome. Audio drives subtle pulses.</small>
          </div>
          <div>
            <label for="flowSelect"><span>Flow alignment</span></label>
            <select id="flowSelect">
              <option value="auto">Let the mural decide</option>
              <option value="sky">Skyline · upper third</option>
              <option value="portrait">Portrait · center band</option>
              <option value="ground">Ground · lower sweep</option>
              <option value="abstract">Abstract drift</option>

    <section class="panel" id="studio">
      <h2>1. Pick a style lane &amp; craft your prompt</h2>
      <div class="layout-grid">
        <div>
          <div class="lane-grid" id="laneCards"></div>
        </div>
        <div class="studio-controls">
          <div class="field">
            <label for="promptInput"><span>Prompt idea</span></label>
            <textarea id="promptInput" rows="3" placeholder="Describe light, materials, emotion, and motion..."></textarea>
          </div>
          <div class="field">
            <label><span>Upload image (or drag &amp; drop)</span></label>
            <div class="upload-zone" id="uploadZone">
              <input type="file" id="imageInput" accept="image/*" hidden />
              <p>Drop a Midjourney / Sora render or click to upload.</p>
              <div>
                <button type="button" id="browseButton">Browse</button>
                <button type="button" id="sampleButton">Quick sample</button>
              </div>
              <small>Max 5MB • We feather and color-match automatically.</small>
            </div>
          </div>
          <div class="field">
            <label><span>Attach soundtrack (optional)</span></label>
            <input type="file" id="audioInput" accept="audio/*" />
            <small>Upload a Udio / Suno track (MP3, WAV). Audio beats drive subtle pulses in the mural.</small>
          </div>
          <div class="field">
            <label for="flowSelect"><span>Flow alignment hint</span></label>
            <select id="flowSelect">
              <option value="none">Let the system choose</option>
              <option value="sky">Skyline / airy top</option>
              <option value="ground">Grounded / horizon focus</option>
              <option value="portrait">Portrait / centered energy</option>
              <option value="abstract">Abstract / freeform</option>

            </select>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" id="previewSection">

      <h2>Preview · keep or retry</h2>
      <div class="preview-wrap">
        <div>
          <canvas id="previewCanvas" width="480" height="320" role="img" aria-label="Preview canvas"></canvas>
          <div class="preview-actions" style="margin-top: 14px;">
            <button type="button" id="retryButton" class="secondary">Clear preview</button>
            <button type="button" id="keepButton">Keep this take</button>
            <span id="statusBar">Load an image from the queue to start.</span>
          </div>
        </div>
        <form id="metadataForm">
          <div>
            <label for="creatorName"><span>Creator credit</span></label>
            <input type="text" id="creatorName" placeholder="Your name or handle" />
          </div>
          <div>
            <label for="altText"><span>Alt text</span></label>
            <textarea id="altText" rows="2" placeholder="Short description for screen readers"></textarea>
          </div>
          <div>
            <label for="captionInput"><span>Caption</span></label>
            <textarea id="captionInput" rows="2" placeholder="What should viewers know about this prompt?"></textarea>
          </div>
          <label class="consent-line">
            <input type="checkbox" id="consentCheck" />
            <span>I created or have rights to this media and grant the nonprofit a non-exclusive license to display and stream it.</span>
          </label>
          <button type="submit" id="submitButton" disabled>Submit to mural</button>

      <h2>2. Preview &amp; prep for the mural</h2>
      <div class="preview-wrap">
        <canvas id="previewCanvas" width="560" height="320"></canvas>
        <div class="preview-actions">
          <button class="secondary" type="button" id="retryButton">Retry / swap image</button>
          <button class="primary" type="button" id="keepButton" disabled>Keep this take</button>
          <span id="statusBar"></span>
        </div>
        <form id="metadataForm">
          <div class="field">
            <label for="creatorName"><span>Creator credit</span></label>
            <input type="text" id="creatorName" placeholder="Your name or handle" />
          </div>
          <div class="field">
            <label for="altText"><span>Alt text</span></label>
            <textarea id="altText" rows="2" placeholder="Short description for screen readers"></textarea>
          </div>
          <div class="field">
            <label for="captionInput"><span>Caption / micro-story</span></label>
            <textarea id="captionInput" rows="2" placeholder="What should visitors know about this prompt?"></textarea>
          </div>
          <label class="consent-line">
            <input type="checkbox" id="consentCheck" />
            <span>I created or have rights to this media (image &amp; audio) and grant the mural a non-exclusive license to
              display, remix, and stream it. I agree to community guidelines.</span>
          </label>
          <button class="primary" type="submit" id="submitButton">Submit to mural</button>

        </form>
      </div>
    </section>

    <section class="panel" id="muralSection">

      <h2>Moodboard mural</h2>
      <div class="mural-wrapper">
        <canvas id="muralCanvas" width="1080" height="640"></canvas>
        <div id="tileTooltip" role="tooltip"></div>
      </div>
      <div class="pill-row" id="tileStats"></div>
      <div class="audio-board" id="audioBoard"></div>
    </section>

    <section class="panel" id="timelapseSection">
      <h2>Timelapse &amp; shareables</h2>
      <div class="preview-actions" style="margin-bottom: 16px;">
        <button type="button" id="playTimelapse">Play timelapse</button>
        <button type="button" id="downloadStill" class="secondary">Download mural still</button>
        <span id="timelapseStatus"></span>
      </div>
      <div id="timelapseDisplay">
        <p style="color: rgba(226, 232, 240, 0.75); font-size: 0.92rem;">Add a few tiles, then play back the mural's growth.</p>
      </div>
    </section>

    <section class="panel" id="literacySection">
      <h2>Literacy &amp; practice</h2>

      <h2>3. Living mural</h2>
      <div id="muralWrapper">
        <canvas id="muralCanvas"></canvas>
      </div>
      <div id="tileTooltip" role="tooltip"></div>
      <div class="mural-meta">
        <div class="pill-row" id="tileStats"></div>
        <div class="pill-row" id="audioStats"></div>
        <div class="audio-board" id="audioControlList"></div>
        <div class="pill-row" id="flowLegend">
          <span class="pill">Flow map legend</span>
          <span class="pill">Skyline zone · top third</span>
          <span class="pill">Portrait zone · mid band</span>
          <span class="pill">Ground zone · bottom sweep</span>
        </div>
      </div>
    </section>

    <section class="panel" id="timelapseSection">
      <h2>4. Timelapse &amp; shareables</h2>
      <div class="preview-actions" style="margin-bottom: 16px;">
        <button class="primary" type="button" id="playTimelapse">Play mural timelapse</button>
        <button class="secondary" type="button" id="downloadStill">Download current mural</button>
        <span id="timelapseStatus"></span>
      </div>
      <div id="timelapseDisplay">
        <p style="color: rgba(226, 232, 240, 0.7); font-size: 0.9rem;">Add a few tiles, then play back the evolution.</p>
      </div>
    </section>

    <section class="panel" id="educationSection">
      <h2>Prompt literacy &amp; community standards</h2>

      <div class="grid-two">
        <div class="micro-module">
          <h3>Prompting for self-expression</h3>
          <ul>

            <li>Combine medium + light + motion: “Impasto oils, dusk sidelight, sweeping brush energy.”</li>
            <li>Anchor to memory: describe a smell, sound, or place that matters.</li>
            <li>Write alt text early—imagine how a friend would understand it without the image.</li>
          </ul>
        </div>
        <div class="micro-module">
          <h3>Respect &amp; rights</h3>
          <ul>
            <li>Only upload media you own or are licensed to share (Udio/Suno allow public performance—still capture consent).</li>
            <li>Credits appear on hover, and every tile stores its license affirmation.</li>
            <li>Report button and moderation queue keep the space safe.</li>
          </ul>
        </div>
        <div class="micro-module">
          <h3>Animation &amp; flow</h3>
          <ul>
            <li>Tiles shimmer softly; audio beats nudge size and glow.</li>
            <li>Flow hints (sky, portrait, ground) keep horizons aligned.</li>
            <li>Global palette nudges each upload toward the day's mood.</li>
          </ul>
        </div>
        <div class="micro-module">
          <h3>AWS-ready path</h3>
          <ul>
            <li>S3 for uploads, Lambda for safety checks, DynamoDB for tile metadata.</li>
            <li>WebSocket channel pushes new tiles and beat markers in real time.</li>
            <li>Optional SageMaker MusicGen endpoint covers in-house soundtrack generation.</li>

            <li>Material + light + gesture: “Impasto oil, warm sidelight, whirlwind brushstrokes.”</li>
            <li>Emotion palette: map feelings to hue (“teal for calm memory, coral for joy”).</li>
            <li>Identity anchors: pull from local landmarks, family stories, or sensory memories.</li>
          </ul>
        </div>
        <div class="micro-module">
          <h3>Ethics &amp; consent</h3>
          <ul>
            <li>No faces or likenesses without permission. Keep remixing respectful.</li>
            <li>Credit matters: names show on hover, and alt text is required for accessibility.</li>
            <li>Report button ready: we quarantine anything flagged for human review.</li>
          </ul>
        </div>
        <div class="micro-module">
          <h3>Animation &amp; audio cues</h3>
          <ul>
            <li>Each lane has a distinct loop: impasto shimmer, cartoon bounce, wash drift.</li>
            <li>Audio beats expand the tile subtly so the mural breathes in sync.</li>
            <li>Theme-of-the-day palette gently nudges hues so the mural stays cohesive.</li>
          </ul>
        </div>
        <div class="micro-module">
          <h3>AWS-ready technical path</h3>
          <ul>
            <li>S3 for uploads, Lambda for safety checks, DynamoDB for tile metadata.</li>
            <li>WebSocket API broadcasts new tiles + beat markers to the mural.</li>
            <li>Optional SageMaker endpoint (MusicGen) backs up user audio uploads.</li>

          </ul>
        </div>
      </div>
    </section>


    <section class="panel" id="reflectionSection">
      <h2>Board notes · art-first lift</h2>
      <ul class="reflection-list">
        <li>Queue lets contributors test multiple Midjourney or Sora takes before sharing.</li>
        <li>Feathered edges, texture overlays, and flow-aware placement read like a unified Midjourney moodboard.</li>
        <li>Audio uploads (Udio, Suno, original tracks) bind neighborhoods; timelapse keeps the installation breathing.</li>
        <li>Next: curator view, public alt-text wall, and nightly recap reels for donors.</li>
      </ul>
    </section>
  </main>
  <footer>Built as a minimal viable prototype for the board review—art-forward, people-first, and ready for grant storytelling.</footer>

  <script>
    const palette = {
      name: 'Aurora Brush Relay',
      colors: ['#0f172a', '#1e293b', '#38bdf8', '#22d3ee', '#fbbf24'],
    };

    const styleLanes = [
      {
        id: 'impasto',
        name: 'Impasto Paint World',
        accent: '#fbbf24',
        description: 'Thick oils, palette knife textures, glowing highlights.',
        tips: ['Name a material (“impasto oil, canvas grain”).', 'Describe light direction.', 'Add a gesture or motion verb.'],
        samplePrompts: [
          'Impasto oil landscape, golden sidelight, palette knives carving tidal brushstrokes.',
          'Thick acrylic portrait, cobalt shadows, restless brush energy and varnish sheen.',
          'Palette knife cityscape, rain-kissed reflections, luminous windows, midnight blues.',
        ],
        feather: 34,

  </main>
  <footer>
    © 2025 · Living Prompt Mural MVP — all in one HTML file for quick demos.
  </footer>

  <script>
    const globalPalette = {
      name: 'Aurora Brush Relay',
      story: 'Warm twilight oranges meet teal shadows to keep edges cohesive.',
      colors: ['#ffbc42', '#f76f8e', '#2ec4b6', '#3b60e4'],
      baseHue: 32
    };

    const laneConfigs = [
      {
        id: 'impasto',
        name: 'Impasto Paint World',
        accent: '#f7ad45',
        description: 'Thick oils, palette knife textures, golden hour light.',
        tips: ['Call out the medium (oil, palette knife).', 'Describe the light direction.', 'Mention surface texture.'],
        edgeFeather: 42,
        paletteHueShift: -8,
        texture: 'impasto',
        tileSize: [240, 340],
        zone: { x: 0.28, y: 0.55 },
        motion: { type: 'shimmer', amplitude: 0.06 }

      },
      {
        id: 'cartoon',
        name: 'Cartoon Pulse',

        accent: '#f472b6',
        description: 'Bold shapes, held poses, expressive line weight.',
        tips: ['Call out character emotion.', 'Name a color family.', 'Add movement (“looped bounce”).'],
        samplePrompts: [
          'Cartoon duo dancing in neon alley, bold cel shading, playful rim light.',
          'Graphic novel hero, exaggerated foreshortening, pink + cyan glow, looping head nod.',
          'Storyboard frame of friends at a diner, warm halos, comic halftones, laughter energy.',
        ],
        feather: 30,

        accent: '#7bdff2',
        description: 'Bold outlines, flat colors, playful exaggeration.',
        tips: ['Use action verbs.', 'Emphasize color blocking.', 'Add a sound effect cue.'],
        edgeFeather: 34,
        paletteHueShift: 12,
        texture: 'cartoon',
        tileSize: [220, 320],
        zone: { x: 0.56, y: 0.4 },
        motion: { type: 'bounce', amplitude: 0.08 }

      },
      {
        id: 'wash',
        name: 'Line & Wash',

        accent: '#38bdf8',
        description: 'Ink contours with watercolor atmospheres.',
        tips: ['Specify ink weight.', 'Name wash colors.', 'Describe softness (“edges bleeding gently”).'],
        samplePrompts: [
          'Ink skyline, ultramarine and peach washes, breeze-tossed clouds, skyline continuity.',
          'Botanical study, loose graphite lines, teal wash pooling at the base, afternoon light.',
          'Neighborhood stoop portrait, sepia ink, indigo wash, friends laughing into dusk.',
        ],
        feather: 32,
      },
      {
        id: 'photocollage',
        name: 'Photocollage Drift',
        accent: '#a855f7',
        description: 'Mixed media layers, print textures, cinematic glow.',
        tips: ['Mention source textures.', 'Describe focal distance.', 'Add overlay or paper note.'],
        samplePrompts: [
          'Photocollage of archival posters, torn paper edges, saffron light spilling through.',
          'Dreamy collage of community garden, 35mm grain, double exposure silhouettes, dusk.',
          'Magazine cutouts forming a river, xerox grit, turquoise flare, gently drifting.',
        ],
        feather: 36,
      },
    ];

    const state = {
      lane: styleLanes[0],
      queue: [],
      activeItem: null,
      previewData: null,
      audio: null,
      audioUrl: null,
      tiles: [],
      timelapseFrames: [],
      timelapseTimer: null,
      playingTimelapse: false,
    };

    const laneGrid = document.getElementById('laneGrid');
    const paletteStrip = document.getElementById('paletteStrip');
    const paletteName = document.getElementById('paletteName');
    const promptInput = document.getElementById('promptInput');
    const uploadZone = document.getElementById('uploadZone');
    const imageInput = document.getElementById('imageInput');
    const browseButton = document.getElementById('browseButton');
    const queueList = document.getElementById('queueList');
    const queueCount = document.getElementById('queueCount');
    const sampleCanvas = document.getElementById('sampleCanvas');
    const samplePrompt = document.getElementById('samplePrompt');
    const refreshSample = document.getElementById('refreshSample');
    const useSample = document.getElementById('useSample');

        accent: '#c3aed6',
        description: 'Ink outlines with watery color gradients and paper grain.',
        tips: ['Describe ink weight.', 'Note where water bleeds.', 'Reference paper mood.'],
        edgeFeather: 38,
        paletteHueShift: -22,
        texture: 'wash',
        tileSize: [220, 310],
        zone: { x: 0.74, y: 0.5 },
        motion: { type: 'float', amplitude: 0.05 }
      },
      {
        id: 'photocollage',
        name: 'Photo Collage',
        accent: '#ff9a8d',
        description: 'Cut-paper, magazine layers, mixed-media edges.',
        tips: ['Layer at least three materials.', 'Mention torn or clean edges.', 'Set a color anchor.'],
        edgeFeather: 28,
        paletteHueShift: 6,
        texture: 'paper',
        tileSize: [230, 340],
        zone: { x: 0.44, y: 0.72 },
        motion: { type: 'drift', amplitude: 0.04 }
      }
    ];

    const state = {
      selectedLane: laneConfigs[0],
      previewImage: null,
      previewRender: null,
      pendingAudio: null,
      readyForMetadata: false,
      muralTiles: [],
      nextTileId: 1,
      highlightTileId: null,
      audioContext: null,
      timelapseFrames: [],
      timelapseTimer: null,
      isPlayingTimelapse: false,
      selectedTileId: null
    };

    const paletteSwatches = document.getElementById('paletteSwatches');
    const paletteName = document.getElementById('paletteName');
    const laneCardsContainer = document.getElementById('laneCards');
    const promptInput = document.getElementById('promptInput');
    const imageInput = document.getElementById('imageInput');
    const uploadZone = document.getElementById('uploadZone');
    const browseButton = document.getElementById('browseButton');
    const sampleButton = document.getElementById('sampleButton');
    const audioInput = document.getElementById('audioInput');

    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const keepButton = document.getElementById('keepButton');
    const retryButton = document.getElementById('retryButton');

    const statusBar = document.getElementById('statusBar');
    const metadataForm = document.getElementById('metadataForm');
    const submitButton = document.getElementById('submitButton');
    const flowSelect = document.getElementById('flowSelect');
    const audioInput = document.getElementById('audioInput');

    const metadataForm = document.getElementById('metadataForm');
    const consentCheck = document.getElementById('consentCheck');
    const statusBar = document.getElementById('statusBar');

    const muralCanvas = document.getElementById('muralCanvas');
    const muralCtx = muralCanvas.getContext('2d');
    const tileTooltip = document.getElementById('tileTooltip');
    const tileStats = document.getElementById('tileStats');

    const audioBoard = document.getElementById('audioBoard');
    const timelapseDisplay = document.getElementById('timelapseDisplay');
    const playTimelapse = document.getElementById('playTimelapse');
    const downloadStill = document.getElementById('downloadStill');
    const timelapseStatus = document.getElementById('timelapseStatus');

    const creatorName = document.getElementById('creatorName');
    const altText = document.getElementById('altText');
    const captionInput = document.getElementById('captionInput');
    const consentCheck = document.getElementById('consentCheck');

    function init() {
      paletteName.textContent = palette.name;
      palette.colors.forEach((color) => {
        const swatch = document.createElement('span');
        swatch.style.background = color;
        paletteStrip.appendChild(swatch);
      });
      renderLaneCards();
      selectLane(styleLanes[0].id);
      clearPreviewCanvas('Load an image from the queue to start.');
      updateQueueDisplay();
      renderMural();
      updateStats();
      renderAudioBoard();
      addEventListeners();
    }

    function renderLaneCards() {
      laneGrid.innerHTML = '';
      styleLanes.forEach((lane) => {
        const card = document.createElement('div');
        card.className = 'lane-card';
        card.dataset.lane = lane.id;
        card.innerHTML = `
          <div style="display:flex;align-items:center;gap:10px;">
            <span style="width:14px;height:14px;border-radius:4px;background:${lane.accent};"></span>
            <h3>${lane.name}</h3>
          </div>
          <p>${lane.description}</p>
          <ul>${lane.tips.map((tip) => `<li>${tip}</li>`).join('')}</ul>
        `;
        card.addEventListener('click', () => selectLane(lane.id));
        laneGrid.appendChild(card);
      });
    }

    function selectLane(laneId) {
      const lane = styleLanes.find((entry) => entry.id === laneId);
      if (!lane) return;
      state.lane = lane;
      document
        .querySelectorAll('.lane-card')
        .forEach((card) => card.classList.toggle('active', card.dataset.lane === laneId));
      loadSamplePrompt();
      if (state.activeItem && state.activeItem.image) {
        drawPreview(state.activeItem.image);
      }
    }

    function loadSamplePrompt() {
      const prompts = state.lane.samplePrompts;
      const choice = prompts[Math.floor(Math.random() * prompts.length)];
      samplePrompt.textContent = choice;
      drawSampleTile();
    }

    function drawSampleTile() {
      const ctx = sampleCanvas.getContext('2d');
      const { width, height } = sampleCanvas;
      ctx.clearRect(0, 0, width, height);
      const gradient = ctx.createRadialGradient(width * 0.3, height * 0.3, 20, width * 0.8, height * 0.8, width);
      gradient.addColorStop(0, hexToRgba(state.lane.accent, 0.9));
      gradient.addColorStop(1, hexToRgba('#0f172a', 0.2));
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = hexToRgba('#ffffff', 0.2);
      ctx.lineWidth = 4;
      ctx.strokeRect(8, 8, width - 16, height - 16);
    }

    function addEventListeners() {
      browseButton.addEventListener('click', () => imageInput.click());
      imageInput.addEventListener('change', (event) => handleFiles(event.target.files));
      uploadZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        uploadZone.classList.add('dragover');
      });
      uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
      uploadZone.addEventListener('drop', (event) => {
        event.preventDefault();
        uploadZone.classList.remove('dragover');
        if (event.dataTransfer?.files) {
          handleFiles(event.dataTransfer.files);
        }
      });
      refreshSample.addEventListener('click', loadSamplePrompt);
      useSample.addEventListener('click', () => {
        promptInput.value = samplePrompt.textContent;
        statusBar.textContent = 'Sample prompt loaded. Pair it with an upload.';
      });
      keepButton.addEventListener('click', confirmPreview);
      retryButton.addEventListener('click', () => {
        state.previewData = null;
        keepButton.disabled = true;
        submitButton.disabled = true;
        statusBar.textContent = 'Preview cleared. Select another item from the queue.';
        drawPreviewBackground();
      });
      metadataForm.addEventListener('submit', handleSubmit);
      audioInput.addEventListener('change', handleAudio);
      playTimelapse.addEventListener('click', toggleTimelapse);
      downloadStill.addEventListener('click', downloadMuralStill);
      muralCanvas.addEventListener('mousemove', handleMuralHover);
      muralCanvas.addEventListener('mouseleave', () => {
        tileTooltip.style.opacity = 0;
      });
    }

    function handleFiles(fileList) {
      const files = Array.from(fileList || []);
      if (!files.length) return;
      files.forEach((file) => {
        if (!file.type.startsWith('image/')) {
          statusBar.textContent = `${file.name} skipped—only images are supported.`;
          return;

    const audioStats = document.getElementById('audioStats');
    const audioControlList = document.getElementById('audioControlList');
    const playTimelapseButton = document.getElementById('playTimelapse');
    const downloadStillButton = document.getElementById('downloadStill');
    const timelapseDisplay = document.getElementById('timelapseDisplay');
    const timelapseStatus = document.getElementById('timelapseStatus');
    const flowSelect = document.getElementById('flowSelect');

    function init() {
      paletteName.textContent = globalPalette.name;
      paletteSwatches.innerHTML = '';
      globalPalette.colors.forEach((color) => {
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = color;
        paletteSwatches.appendChild(sw);
      });

      renderLaneCards();
      selectLane(state.selectedLane.id);
      drawPreviewPlaceholder();
      resizeMuralCanvas();
      window.addEventListener('resize', resizeMuralCanvas);

      browseButton.addEventListener('click', () => imageInput.click());
      sampleButton.addEventListener('click', async () => {
        if (!state.selectedLane) return;
        setStatus('Generating a quick sample...');
        const img = await generateLaneSample(state.selectedLane);
        setPreviewImage(img, 'Sample generated for ' + state.selectedLane.name);
      });

      imageInput.addEventListener('change', (event) => {
        if (event.target.files && event.target.files[0]) {
          loadImageFile(event.target.files[0]);
        }
      });

      uploadZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        uploadZone.classList.add('dragging');
      });
      uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragging'));
      uploadZone.addEventListener('drop', (event) => {
        event.preventDefault();
        uploadZone.classList.remove('dragging');
        const file = event.dataTransfer.files && event.dataTransfer.files[0];
        if (file) {
          loadImageFile(file);

        }
        if (file.size > 10 * 1024 * 1024) {
          statusBar.textContent = `${file.name} is over 10MB. Please compress and try again.`;
          return;
        }
        const entry = {
          id: `${Date.now()}-${Math.random().toString(36).slice(2)}`,
          file,
          status: 'loading',
          name: file.name,
          sizeLabel: formatFileSize(file.size),
          dataUrl: '',
          image: null,
          width: 0,
          height: 0,
        };
        state.queue.push(entry);
        const reader = new FileReader();
        reader.onload = (e) => {
          entry.dataUrl = e.target?.result;
          const img = new Image();
          img.onload = () => {
            entry.image = img;
            entry.width = img.width;
            entry.height = img.height;
            entry.status = 'ready';
            updateQueueDisplay();
            if (!state.activeItem) {
              setActiveQueue(entry.id);
            }
          };
          img.src = entry.dataUrl;
        };
        reader.onerror = () => {
          entry.status = 'error';
          statusBar.textContent = `Could not read ${file.name}.`;
          updateQueueDisplay();
        };
        reader.readAsDataURL(file);
      });

      updateQueueDisplay();
    }

    function updateQueueDisplay() {
      queueCount.textContent = state.queue.length;
      if (state.queue.length === 0) {
        queueList.hidden = true;
        queueList.innerHTML = '';
        return;
      }
      queueList.hidden = false;
      queueList.innerHTML = '';
      state.queue.forEach((entry) => {
        const item = document.createElement('div');
        item.className = 'queue-item';
        if (state.activeItem?.id === entry.id) {
          item.classList.add('active');
        }
        const thumb = document.createElement('div');
        thumb.className = 'queue-thumb';
        if (entry.dataUrl) {
          const img = document.createElement('img');
          img.src = entry.dataUrl;
          img.alt = entry.name;
          thumb.appendChild(img);
        } else {
          thumb.textContent = '…';
        }
        const meta = document.createElement('div');
        meta.className = 'queue-meta';
        meta.innerHTML = `<span>${entry.name}</span><small>${entry.sizeLabel} · ${entry.status}</small>`;
        item.append(thumb, meta);
        item.addEventListener('click', () => setActiveQueue(entry.id));
        queueList.appendChild(item);
      });
    }

    function setActiveQueue(id) {
      const entry = state.queue.find((item) => item.id === id);
      if (!entry || entry.status !== 'ready') {
        statusBar.textContent = 'Still loading. Please wait a moment.';
        return;
      }
      state.activeItem = entry;
      state.previewData = null;
      keepButton.disabled = false;
      submitButton.disabled = true;
      statusBar.textContent = 'Preview loaded—tweak prompt or try keep.';
      drawPreview(entry.image);
      updateQueueDisplay();
    }

    function drawPreview(image) {
      drawPreviewBackground();
      if (!image) return;
      const maxWidth = previewCanvas.width - 80;
      const maxHeight = previewCanvas.height - 80;
      const { width, height } = fitWithin(image.width, image.height, maxWidth, maxHeight);
      const offscreen = document.createElement('canvas');
      offscreen.width = width;
      offscreen.height = height;
      const offCtx = offscreen.getContext('2d');
      offCtx.drawImage(image, 0, 0, width, height);
      applyFeather(offCtx, width, height, state.lane.feather);
      offCtx.globalAlpha = 0.18;
      offCtx.fillStyle = state.lane.accent;
      offCtx.fillRect(0, 0, width, height);
      previewCtx.drawImage(offscreen, (previewCanvas.width - width) / 2, (previewCanvas.height - height) / 2);
    }

    function drawPreviewBackground(message) {
      previewCtx.fillStyle = hexToRgba('#020617', 0.92);
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.strokeStyle = hexToRgba(state.lane.accent, 0.25);
      previewCtx.setLineDash([6, 6]);
      previewCtx.strokeRect(24, 24, previewCanvas.width - 48, previewCanvas.height - 48);
      previewCtx.setLineDash([]);
      if (message) {
        previewCtx.fillStyle = hexToRgba('#e2e8f0', 0.7);
        previewCtx.font = '500 16px Inter';
        previewCtx.textAlign = 'center';
        previewCtx.fillText(message, previewCanvas.width / 2, previewCanvas.height / 2);
      }
    }

    function confirmPreview() {
      if (!state.activeItem || !state.activeItem.image) {
        statusBar.textContent = 'Load an image first.';
        return;


      audioInput.addEventListener('change', (event) => {
        if (event.target.files && event.target.files[0]) {
          loadAudioFile(event.target.files[0]);
        }
      });

      keepButton.addEventListener('click', () => {
        if (!state.previewRender) return;
        metadataForm.classList.add('visible');
        state.readyForMetadata = true;
        keepButton.disabled = true;
        setStatus('Locked. Add your credit, alt text, and consent, then submit.');
      });

      retryButton.addEventListener('click', resetPreviewState);

      metadataForm.addEventListener('submit', (event) => {
        event.preventDefault();
        if (!state.previewRender) return;
        if (!consentCheck.checked) {
          setStatus('Please confirm the consent & rights checkbox before submitting.', true);
          return;
        }
        const creatorName = document.getElementById('creatorName').value.trim();
        const altText = document.getElementById('altText').value.trim();
        const caption = document.getElementById('captionInput').value.trim();
        const promptText = promptInput.value.trim();
        submitTile({ creatorName, altText, caption, promptText });
      });

      muralCanvas.addEventListener('mousemove', handleMuralHover);
      muralCanvas.addEventListener('mouseleave', () => (tileTooltip.style.opacity = 0));

      playTimelapseButton.addEventListener('click', toggleTimelapsePlayback);
      downloadStillButton.addEventListener('click', downloadCurrentMural);

      requestAnimationFrame(renderMural);
    }

    function renderLaneCards() {
      laneCardsContainer.innerHTML = '';
      laneConfigs.forEach((lane) => {
        const card = document.createElement('button');
        card.type = 'button';
        card.className = 'lane-card';
        card.dataset.lane = lane.id;
        card.innerHTML = `
          <div class="accent-dot" style="background:${lane.accent}"></div>
          <h3>${lane.name}</h3>
          <p style="color: rgba(226,232,240,0.72); font-size: 0.9rem;">${lane.description}</p>
          <ul>${lane.tips.map((tip) => `<li>${tip}</li>`).join('')}</ul>
        `;
        card.addEventListener('click', () => selectLane(lane.id));
        laneCardsContainer.appendChild(card);
      });
    }

    function selectLane(laneId) {
      const lane = laneConfigs.find((l) => l.id === laneId);
      if (!lane) return;
      state.selectedLane = lane;
      document.querySelectorAll('.lane-card').forEach((card) => {
        card.classList.toggle('active', card.dataset.lane === laneId);
      });
      if (state.previewImage && !state.readyForMetadata) {
        buildPreviewRender();
      }
      setStatus(`Lane set to ${lane.name}. Use the quick sample to preview the look or upload your own image.`);
    }

    function setStatus(message, isError = false) {
      statusBar.textContent = message || '';
      statusBar.style.color = isError ? '#f87171' : 'rgba(148, 163, 184, 0.88)';
    }

    function loadImageFile(file) {
      if (!file.type.startsWith('image/')) {
        setStatus('Please upload an image file (PNG, JPG, WEBP).', true);
        return;
      }
      if (file.size > 5 * 1024 * 1024) {
        setStatus('File too large. Please keep it under 5MB for the demo.', true);
        return;
      }
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => setPreviewImage(img, `Loaded ${file.name}`);
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    function setPreviewImage(img, message) {
      state.previewImage = img;
      state.readyForMetadata = false;
      metadataForm.classList.remove('visible');
      keepButton.disabled = false;
      consentCheck.checked = false;
      buildPreviewRender();
      setStatus(message || 'Preview ready. Click “Keep this take” when you like it.');
    }

    function buildPreviewRender() {
      if (!state.previewImage || !state.selectedLane) return;
      state.previewRender = createTileRender(state.previewImage, state.selectedLane);
      drawPreviewCanvas();
    }

    function drawPreviewCanvas() {
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = 'rgba(10, 14, 22, 0.9)';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      if (!state.previewRender) {
        drawPreviewPlaceholder();
        return;
      }
      const render = state.previewRender;
      const scale = Math.min(
        (previewCanvas.width * 0.82) / render.canvas.width,
        (previewCanvas.height * 0.82) / render.canvas.height
      );
      const offsetX = (previewCanvas.width - render.canvas.width * scale) / 2;
      const offsetY = (previewCanvas.height - render.canvas.height * scale) / 2;
      previewCtx.save();
      previewCtx.translate(offsetX, offsetY);
      previewCtx.scale(scale, scale);
      previewCtx.drawImage(render.canvas, 0, 0);
      previewCtx.restore();
      previewCtx.fillStyle = 'rgba(226, 232, 240, 0.68)';
      previewCtx.font = '600 14px Inter';
      previewCtx.fillText(state.selectedLane.name, 18, previewCanvas.height - 24);
    }

    function drawPreviewPlaceholder() {
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = 'rgba(10, 14, 22, 0.9)';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = 'rgba(148, 163, 184, 0.7)';
      previewCtx.font = '600 18px Inter';
      previewCtx.fillText('Upload or generate a sample to preview blending.', 36, previewCanvas.height / 2);
    }

    function resetPreviewState() {
      state.previewImage = null;
      state.previewRender = null;
      state.readyForMetadata = false;
      metadataForm.classList.remove('visible');
      document.getElementById('creatorName').value = '';
      document.getElementById('altText').value = '';
      document.getElementById('captionInput').value = '';
      consentCheck.checked = false;
      keepButton.disabled = true;
      setStatus('Preview cleared. Upload another image or generate a sample.');
      drawPreviewPlaceholder();
    }

    function createTileRender(image, lane) {
      const longest = lane.tileSize[0] + Math.random() * (lane.tileSize[1] - lane.tileSize[0]);
      const ratio = image.width / image.height;
      let width, height;
      if (ratio >= 1) {
        width = longest;
        height = longest / ratio;
      } else {
        height = longest;
        width = longest * ratio;
      }
      width = Math.max(180, Math.min(width, 420));
      height = Math.max(180, Math.min(height, 420));
      const canvas = document.createElement('canvas');
      canvas.width = Math.round(width);
      canvas.height = Math.round(height);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      const averageColor = getAverageColor(ctx, canvas.width, canvas.height);
      applyFeatherMask(ctx, canvas.width, canvas.height, lane.edgeFeather);
      applyPaletteTint(ctx, canvas.width, canvas.height, lane, averageColor);
      applyTextureOverlay(ctx, canvas.width, canvas.height, lane);
      return { canvas, width: canvas.width, height: canvas.height, laneId: lane.id, averageColor };
    }
    function applyFeatherMask(ctx, width, height, feather) {
      const f = Math.min(feather, Math.floor(Math.min(width, height) / 3));
      ctx.globalCompositeOperation = 'destination-out';

      let gradient = ctx.createLinearGradient(0, 0, 0, f);
      gradient.addColorStop(0, 'rgba(0,0,0,1)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, f);

      gradient = ctx.createLinearGradient(0, height - f, 0, height);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, height - f, width, f);

      gradient = ctx.createLinearGradient(0, 0, f, 0);
      gradient.addColorStop(0, 'rgba(0,0,0,1)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, f, height);

      gradient = ctx.createLinearGradient(width - f, 0, width, 0);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, 'rgba(0,0,0,1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(width - f, 0, f, height);

      ctx.globalCompositeOperation = 'source-over';
    }

    function applyPaletteTint(ctx, width, height, lane, averageColor) {
      const targetHue = (globalPalette.baseHue + (lane.paletteHueShift || 0) + 360) % 360;
      const overlayColor = `hsla(${targetHue}, 64%, 52%, 0.16)`;
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = overlayColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
      if (averageColor) {
        const avgHsl = rgbToHsl(averageColor.r, averageColor.g, averageColor.b);
        const hueDiff = Math.abs(avgHsl.h - targetHue);
        if (hueDiff > 24) {
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = `hsla(${targetHue}, 50%, 52%, 0.9)`;
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }
      }
    }

    const textureCache = new Map();

    function getTexturePattern(type) {
      if (textureCache.has(type)) return textureCache.get(type);
      const size = 180;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, size, size);
      switch (type) {
        case 'impasto':
          for (let i = 0; i < 120; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const length = 20 + Math.random() * 60;
            const angle = Math.random() * Math.PI * 2;
            const thickness = 4 + Math.random() * 6;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.05 + Math.random() * 0.08})`;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
            ctx.stroke();
          }
          break;
        case 'cartoon':
          for (let i = 0; i < 60; i++) {
            ctx.strokeStyle = `rgba(0, 0, 0, ${0.06 + Math.random() * 0.08})`;
            ctx.lineWidth = 3;
            const x = Math.random() * size;
            const y = Math.random() * size;
            const radius = 12 + Math.random() * 18;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
          }
          break;
        case 'wash':
          const gradient = ctx.createLinearGradient(0, 0, size, size);
          gradient.addColorStop(0, 'rgba(255,255,255,0.1)');
          gradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, size, size);
          for (let i = 0; i < 30; i++) {
            ctx.fillStyle = `rgba(255,255,255,${0.04 + Math.random() * 0.05})`;
            const w = size * (0.4 + Math.random() * 0.4);
            const h = 8 + Math.random() * 12;
            const x = Math.random() * (size - w);
            const y = Math.random() * (size - h);
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
        default:
          for (let i = 0; i < 80; i++) {
            ctx.fillStyle = `rgba(255,255,255,${0.05 + Math.random() * 0.05})`;
            const w = 12 + Math.random() * 30;
            const h = 6 + Math.random() * 20;
            const x = Math.random() * (size - w);
            const y = Math.random() * (size - h);
            ctx.fillRect(x, y, w, h);
          }
      }
      textureCache.set(type, canvas);
      return canvas;
    }

    function applyTextureOverlay(ctx, width, height, lane) {
      const patternCanvas = getTexturePattern(lane.texture || 'default');
      const pattern = ctx.createPattern(patternCanvas, 'repeat');
      ctx.save();
      ctx.globalAlpha = lane.texture === 'cartoon' ? 0.18 : 0.12;
      ctx.globalCompositeOperation = 'soft-light';
      ctx.fillStyle = pattern;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    function getAverageColor(ctx, width, height) {
      const sampleSize = 40;
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = sampleSize;
      tempCanvas.height = sampleSize;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(ctx.canvas, 0, 0, sampleSize, sampleSize);
      const data = tempCtx.getImageData(0, 0, sampleSize, sampleSize).data;
      let r = 0, g = 0, b = 0;
      const totalPixels = data.length / 4;
      for (let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i + 1];
        b += data[i + 2];
      }
      return { r: r / totalPixels, g: g / totalPixels, b: b / totalPixels };
    }

    function submitTile(meta) {
      if (!state.previewRender || !state.selectedLane) return;
      const tileCanvas = document.createElement('canvas');
      tileCanvas.width = state.previewRender.canvas.width;
      tileCanvas.height = state.previewRender.canvas.height;
      tileCanvas.getContext('2d').drawImage(state.previewRender.canvas, 0, 0);
      const tile = {
        id: state.nextTileId++,
        lane: state.selectedLane,
        canvas: tileCanvas,
        width: tileCanvas.width,
        height: tileCanvas.height,
        meta: {
          ...meta,
          prompt: meta.promptText,
          laneId: state.selectedLane.id,
          flow: flowSelect.value,
          createdAt: new Date()
        },
        audio: state.pendingAudio ? { ...state.pendingAudio } : null,
        pulse: 0,
        flash: 1
      };
      placeTile(tile);
      state.muralTiles.push(tile);
      if (tile.audio) {
        setupAudioAnalyser(tile);
        state.pendingAudio = null;
      }
      captureTimelapseFrame();
      updateStats();
      updateAudioBoard();
      highlightTile(tile.id);
      setStatus('Submitted to the mural! Scroll down to see it blend in.');
      resetPreviewState();
    }

    function placeTile(tile) {
      const width = 1280;
      const height = 720;
      const zone = tile.lane.zone || { x: 0.5, y: 0.5 };
      const margin = 60;
      let attempt = 0;
      let bestX = zone.x * width;
      let bestY = zone.y * height;
      while (attempt < 240) {
        let x = zone.x * width + (Math.random() - 0.5) * 280;
        let y = zone.y * height + (Math.random() - 0.5) * 220;
        switch (tile.meta.flow) {
          case 'sky':
            y = height * 0.22 + (Math.random() - 0.5) * 80;
            break;
          case 'ground':
            y = height * 0.78 + (Math.random() - 0.5) * 90;
            break;
          case 'portrait':
            y = height * 0.5 + (Math.random() - 0.5) * 120;
            break;
          default:
            break;
        }
        x = Math.max(margin + tile.width / 2, Math.min(width - margin - tile.width / 2, x));
        y = Math.max(margin + tile.height / 2, Math.min(height - margin - tile.height / 2, y));
        const minDistance = Math.max(tile.width, tile.height) * 0.65;
        let valid = true;
        for (const other of state.muralTiles) {
          const dx = other.x - x;
          const dy = other.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const needed = (Math.max(other.width, other.height) * 0.6) + minDistance;
          if (distance < needed) {
            valid = false;
            break;
          }
        }
        if (valid) {
          bestX = x;
          bestY = y;
          break;
        }
        attempt++;
      }
      tile.x = bestX;
      tile.y = bestY;
    }

    function highlightTile(tileId) {
      state.highlightTileId = tileId;
      setTimeout(() => {
        if (state.highlightTileId === tileId) {
          state.highlightTileId = null;
        }
      }, 4000);
    }

    function renderMural(timestamp) {
      const width = 1280;
      const height = 720;
      muralCtx.clearRect(0, 0, width, height);
      const bgGradient = muralCtx.createLinearGradient(0, 0, width, height);
      bgGradient.addColorStop(0, 'rgba(8,12,20,0.96)');
      bgGradient.addColorStop(1, 'rgba(9,16,26,0.96)');
      muralCtx.fillStyle = bgGradient;
      muralCtx.fillRect(0, 0, width, height);

      state.muralTiles.forEach((tile) => {
        if (tile.audio && tile.audio.analyser) {
          tile.audio.analyser.getByteFrequencyData(tile.audio.freqData);
          let sum = 0;
          for (let i = 0; i < tile.audio.freqData.length; i++) {
            sum += tile.audio.freqData[i];
          }
          const avg = sum / tile.audio.freqData.length / 255;
          tile.pulse = tile.pulse * 0.75 + avg * 0.7;
        } else {
          tile.pulse *= 0.9;
        }
        tile.flash *= 0.94;
        const laneAmp = tile.lane.motion ? tile.lane.motion.amplitude : 0.05;
        const scale = 1 + tile.pulse * laneAmp + tile.flash * 0.08;
        muralCtx.save();
        muralCtx.translate(tile.x, tile.y);
        muralCtx.scale(scale, scale);
        muralCtx.drawImage(tile.canvas, -tile.width / 2, -tile.height / 2);
        if (state.highlightTileId === tile.id) {
          muralCtx.strokeStyle = 'rgba(79, 209, 197, 0.8)';
          muralCtx.lineWidth = 4;
          muralCtx.strokeRect(-tile.width / 2, -tile.height / 2, tile.width, tile.height);
        }
        applyMotionOverlay(muralCtx, tile, timestamp);
        muralCtx.restore();
      });

      requestAnimationFrame(renderMural);
    }

    function applyMotionOverlay(ctx, tile, timestamp) {
      ctx.save();
      const t = timestamp / 1000;
      switch (tile.lane.motion && tile.lane.motion.type) {
        case 'shimmer':
          ctx.globalAlpha = 0.18 + tile.pulse * 0.35;
          ctx.globalCompositeOperation = 'lighter';
          const gradient = ctx.createLinearGradient(-tile.width / 2, -tile.height / 2, tile.width / 2, tile.height / 2);
          gradient.addColorStop(0, 'rgba(255,255,255,0)');
          gradient.addColorStop(1, 'rgba(255,255,255,0.8)');
          ctx.fillStyle = gradient;
          ctx.rotate(Math.sin(t * 0.6 + tile.id) * 0.2);
          ctx.fillRect(-tile.width / 2, -tile.height / 2, tile.width, tile.height);
          break;
        case 'bounce':
          ctx.globalAlpha = 0.12 + tile.pulse * 0.25;
          ctx.globalCompositeOperation = 'screen';
          const bounce = Math.sin(t * 3 + tile.id);
          ctx.translate(0, bounce * 6);
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillRect(-tile.width / 2, tile.height / 2 - 6, tile.width, 12);
          break;
        case 'float':
          ctx.globalAlpha = 0.14 + tile.pulse * 0.2;
          ctx.globalCompositeOperation = 'lighter';
          ctx.translate(0, Math.sin(t * 1.3 + tile.id) * 4);
          ctx.fillStyle = 'rgba(255,255,255,0.35)';
          ctx.beginPath();
          ctx.ellipse(0, tile.height / 2 - 12, tile.width * 0.6, 18, 0, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'drift':
          ctx.globalAlpha = 0.16 + tile.pulse * 0.2;
          ctx.globalCompositeOperation = 'overlay';
          ctx.rotate(Math.sin(t * 0.9 + tile.id) * 0.1);
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.fillRect(-tile.width / 2, -tile.height / 2, tile.width, tile.height / 6);
          break;
        default:
          break;
      }
      ctx.restore();
    }

    function handleMuralHover(event) {
      const rect = muralCanvas.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 1280;
      const y = ((event.clientY - rect.top) / rect.height) * 720;
      let hovered = null;
      for (let i = state.muralTiles.length - 1; i >= 0; i--) {
        const tile = state.muralTiles[i];
        const halfW = tile.width / 2;
        const halfH = tile.height / 2;
        if (x >= tile.x - halfW && x <= tile.x + halfW && y >= tile.y - halfH && y <= tile.y + halfH) {
          hovered = tile;
          break;
        }
      }
      if (hovered) {
        tileTooltip.innerHTML = `
          <strong>${hovered.meta.creatorName || 'Anonymous'}</strong><br />
          <span>${hovered.lane.name}</span><br />
          <em>${hovered.meta.prompt || 'Untitled prompt'}</em>
        `;
        tileTooltip.style.opacity = 1;
        tileTooltip.style.transform = `translate(${event.clientX + 16}px, ${event.clientY + 16}px)`;
      } else {
        tileTooltip.style.opacity = 0;

      }
      state.previewData = {
        queueId: state.activeItem.id,
        image: state.activeItem.image,
        prompt: promptInput.value.trim(),
        lane: state.lane,
        flow: flowSelect.value,
        audio: state.audio,
        audioUrl: state.audioUrl,
      };
      submitButton.disabled = false;
      statusBar.textContent = 'Locked in. Add credit + consent, then submit.';
    }


    function handleSubmit(event) {
      event.preventDefault();
      if (!state.previewData) {
        statusBar.textContent = 'Select “Keep this take” before submitting.';
        return;
      }
      if (!consentCheck.checked) {
        statusBar.textContent = 'Consent is required to submit.';
        return;
      }
      const tile = buildTile();
      state.tiles.push(tile);
      renderMural();
      state.timelapseFrames.push(muralCanvas.toDataURL('image/webp', 0.9));
      updateStats();
      renderAudioBoard();
      resetPreviewAfterSubmit();
      statusBar.textContent = 'Submitted to mural. Scroll down to see the placement.';
    }

    function buildTile() {
      const baseWidth = 220 + Math.random() * 90;
      const aspect = state.previewData.image.width / state.previewData.image.height || 1;
      const width = baseWidth;
      const height = Math.max(160, baseWidth / aspect);
      const position = findPlacement(width, height, state.previewData.flow);
      return {
        id:
          (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
            ? crypto.randomUUID()
            : `tile-${Date.now()}-${Math.random().toString(16).slice(2)}`),
        image: state.previewData.image,
        width,
        height,
        x: position.x,
        y: position.y,
        lane: state.previewData.lane,
        meta: {
          prompt: state.previewData.prompt,
          creator: creatorName.value.trim() || 'Anonymous',
          caption: captionInput.value.trim(),
          altText: altText.value.trim(),
          flow: state.previewData.flow,
        },
        audio: state.previewData.audio
          ? {
              fileName: state.previewData.audio.name,
              url: state.previewData.audioUrl,
            }
          : null,
      };
    }

    function findPlacement(width, height, flow) {
      const padding = 80;
      const attempts = 160;
      const minDistance = 140;
      const bounds = {
        xMin: padding,
        xMax: muralCanvas.width - padding,
        yMin: padding,
        yMax: muralCanvas.height - padding,
      };
      const flowBias = {
        sky: 0.25,
        portrait: 0.5,
        ground: 0.72,
        abstract: Math.random(),
        auto: Math.random(),
      };
      let targetY = flowBias[flow] ?? Math.random();
      for (let attempt = 0; attempt < attempts; attempt++) {
        const x = bounds.xMin + Math.random() * (bounds.xMax - bounds.xMin);
        const y = bounds.yMin + Math.random() * (bounds.yMax - bounds.yMin);
        const normalizedY = (y - bounds.yMin) / (bounds.yMax - bounds.yMin);
        if (Math.abs(normalizedY - targetY) > 0.25 && flow !== 'auto') continue;
        if (state.tiles.every((tile) => distance(x, y, tile.x, tile.y) > minDistance)) {
          return { x, y };
        }
      }
      return {
        x: muralCanvas.width / 2,
        y: muralCanvas.height / 2,
      };
    }

    function renderMural() {
      muralCtx.fillStyle = hexToRgba('#020617', 0.95);
      muralCtx.fillRect(0, 0, muralCanvas.width, muralCanvas.height);
      state.tiles.forEach((tile) => drawTile(tile));
    }

    function drawTile(tile) {
      const offscreen = document.createElement('canvas');
      offscreen.width = tile.width;
      offscreen.height = tile.height;
      const offCtx = offscreen.getContext('2d');
      offCtx.drawImage(tile.image, 0, 0, tile.width, tile.height);
      applyFeather(offCtx, tile.width, tile.height, tile.lane.feather || 30);
      offCtx.globalAlpha = 0.16;
      offCtx.fillStyle = tile.lane.accent;
      offCtx.fillRect(0, 0, tile.width, tile.height);
      muralCtx.drawImage(offscreen, tile.x - tile.width / 2, tile.y - tile.height / 2);
    }

    function renderAudioBoard() {
      audioBoard.innerHTML = '';
      const withAudio = state.tiles.filter((tile) => tile.audio);
      withAudio.forEach((tile) => {
        const card = document.createElement('div');
        card.className = 'audio-card';
        const info = document.createElement('div');
        info.innerHTML = `<strong>${tile.meta.creator}</strong> · ${tile.audio.fileName}`;
        const playButton = document.createElement('button');
        playButton.textContent = 'Play snippet';
        const audio = new Audio(tile.audio.url);
        playButton.addEventListener('click', () => {
          if (audio.paused) {
            audio.currentTime = 0;
            audio.play();
            playButton.textContent = 'Pause';
          } else {
            audio.pause();
            playButton.textContent = 'Play snippet';
          }
        });
        audio.addEventListener('ended', () => {
          playButton.textContent = 'Play snippet';
        });
        card.append(info, playButton);
        audioBoard.appendChild(card);
      });
    }

    function updateStats() {
      tileStats.innerHTML = '';
      const total = document.createElement('span');
      total.className = 'pill';
      total.textContent = `${state.tiles.length} tiles blended`;
      tileStats.appendChild(total);
      styleLanes.forEach((lane) => {
        const count = state.tiles.filter((tile) => tile.lane.id === lane.id).length;
        if (count > 0) {
          const pill = document.createElement('span');
          pill.className = 'pill';
          pill.textContent = `${lane.name}: ${count}`;
          tileStats.appendChild(pill);
        }
      });
    }

    function resetPreviewAfterSubmit() {
      if (state.previewData?.queueId) {
        state.queue = state.queue.filter((entry) => entry.id !== state.previewData.queueId);
      }
      state.previewData = null;
      state.activeItem = null;
      promptInput.value = '';
      captionInput.value = '';
      creatorName.value = '';
      altText.value = '';
      consentCheck.checked = false;
      state.audio = null;
      if (state.audioUrl) {
        URL.revokeObjectURL(state.audioUrl);
      }
      state.audioUrl = null;
      audioInput.value = '';
      keepButton.disabled = true;
      submitButton.disabled = true;
      updateQueueDisplay();
      drawPreviewBackground('Queue another image to keep building.');
    }

    function handleAudio(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      if (!file.type.startsWith('audio/')) {
        statusBar.textContent = 'Audio upload skipped—file is not audio.';
        return;
      }
      if (state.audioUrl) {
        URL.revokeObjectURL(state.audioUrl);
      }
      state.audio = file;
      state.audioUrl = URL.createObjectURL(file);
      statusBar.textContent = `Audio ready: ${file.name}`;
    }

    function toggleTimelapse() {
      if (state.timelapseFrames.length < 2) {
        timelapseStatus.textContent = 'Add at least two submissions to play the timelapse.';
        return;
      }
      if (state.playingTimelapse) {
        stopTimelapse();
        return;
      }
      let index = 0;
      state.playingTimelapse = true;
      playTimelapse.textContent = 'Stop timelapse';
      timelapseStatus.textContent = '';
      state.timelapseTimer = setInterval(() => {
        const frame = state.timelapseFrames[index % state.timelapseFrames.length];
        timelapseDisplay.innerHTML = `<img src="${frame}" alt="Mural timelapse frame" />`;
        index += 1;
      }, 600);
    }

    function stopTimelapse() {
      state.playingTimelapse = false;
      playTimelapse.textContent = 'Play timelapse';
      clearInterval(state.timelapseTimer);
      timelapseStatus.textContent = 'Timelapse paused.';
    }

    function downloadMuralStill() {
      const link = document.createElement('a');
      link.href = muralCanvas.toDataURL('image/png');
      link.download = 'living-mural.png';
      link.click();
      timelapseStatus.textContent = 'Mural still downloaded.';
    }

    function handleMuralHover(event) {
      const rect = muralCanvas.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * muralCanvas.width;
      const y = ((event.clientY - rect.top) / rect.height) * muralCanvas.height;
      const hovered = state.tiles.find((tile) => isPointInsideTile(x, y, tile));
      if (!hovered) {
        tileTooltip.style.opacity = 0;
        return;
      }
      tileTooltip.innerHTML = `
        <strong>${hovered.meta.creator}</strong><br />
        <span>${hovered.lane.name}</span><br />
        <em>${hovered.meta.prompt || 'Untitled prompt'}</em>
      `;
      tileTooltip.style.left = `${event.clientX - rect.left + 12}px`;
      tileTooltip.style.top = `${event.clientY - rect.top + 12}px`;
      tileTooltip.style.opacity = 1;
    }

    function applyFeather(ctx, width, height, feather = 30) {
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const edgeDistance = Math.min(x, y, width - x, height - y);
          const ratio = edgeDistance < feather ? Math.cos((1 - edgeDistance / feather) * (Math.PI / 2)) : 1;
          const alphaIndex = (y * width + x) * 4 + 3;
          data[alphaIndex] = Math.round(data[alphaIndex] * Math.max(0, Math.min(1, ratio)));
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    function fitWithin(sourceWidth, sourceHeight, maxWidth, maxHeight) {
      const widthRatio = maxWidth / sourceWidth;
      const heightRatio = maxHeight / sourceHeight;
      const ratio = Math.min(widthRatio, heightRatio, 1);
      return {
        width: Math.max(20, Math.round(sourceWidth * ratio)),
        height: Math.max(20, Math.round(sourceHeight * ratio)),
      };
    }

    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    function isPointInsideTile(x, y, tile) {
      return (
        x >= tile.x - tile.width / 2 &&
        x <= tile.x + tile.width / 2 &&
        y >= tile.y - tile.height / 2 &&
        y <= tile.y + tile.height / 2
      );
    }

    function hexToRgba(hex, alpha = 1) {
      const trimmed = hex.replace('#', '');
      const bigint = parseInt(trimmed, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }

    function clearPreviewCanvas(message) {
      drawPreviewBackground(message);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden && state.playingTimelapse) {

    function updateStats() {
      const total = state.muralTiles.length;
      const laneCounts = laneConfigs.map((lane) => {
        const count = state.muralTiles.filter((tile) => tile.lane.id === lane.id).length;
        return { lane, count };
      });
      tileStats.innerHTML = `
        <span class="pill">${total} tiles placed</span>
        ${laneCounts.map((entry) => `<span class="pill">${entry.lane.name}: ${entry.count}</span>`).join('')}
      `;
      const withAudio = state.muralTiles.filter((tile) => tile.audio).length;
      audioStats.innerHTML = `<span class="pill">${withAudio} soundtracks attached</span>`;
    }

    function captureTimelapseFrame() {
      const dataUrl = muralCanvas.toDataURL('image/webp', 0.7);
      state.timelapseFrames.push({ url: dataUrl, label: new Date().toLocaleTimeString() });
      if (state.timelapseFrames.length > 24) {
        state.timelapseFrames.shift();
      }
      timelapseStatus.textContent = `${state.timelapseFrames.length} frames captured`;
      if (!state.isPlayingTimelapse) {
        const img = new Image();
        img.src = dataUrl;
        timelapseDisplay.innerHTML = '';
        timelapseDisplay.appendChild(img);
      }
    }

    function toggleTimelapsePlayback() {
      if (state.isPlayingTimelapse) {
        stopTimelapse();
        return;
      }
      if (state.timelapseFrames.length < 2) {
        timelapseStatus.textContent = 'Add more tiles to build a timelapse.';
        return;
      }
      state.isPlayingTimelapse = true;
      playTimelapseButton.textContent = 'Stop timelapse';
      let frameIndex = 0;
      const img = new Image();
      timelapseDisplay.innerHTML = '';
      timelapseDisplay.appendChild(img);
      state.timelapseTimer = setInterval(() => {
        const frame = state.timelapseFrames[frameIndex];
        img.src = frame.url;
        timelapseStatus.textContent = `Frame ${frameIndex + 1} / ${state.timelapseFrames.length} · ${frame.label}`;
        frameIndex = (frameIndex + 1) % state.timelapseFrames.length;
      }, 700);
    }

    function stopTimelapse() {
      state.isPlayingTimelapse = false;
      playTimelapseButton.textContent = 'Play mural timelapse';
      clearInterval(state.timelapseTimer);
      state.timelapseTimer = null;
      timelapseStatus.textContent = `${state.timelapseFrames.length} frames captured`;
    }

    function downloadCurrentMural() {
      const dataUrl = muralCanvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = 'living-mural.png';
      link.click();
    }

    function loadAudioFile(file) {
      if (!file.type.startsWith('audio/')) {
        setStatus('Audio file must be MP3 or WAV.', true);
        return;
      }
      const url = URL.createObjectURL(file);
      const audioElement = new Audio(url);
      audioElement.loop = true;
      audioElement.preload = 'auto';
      state.pendingAudio = {
        fileName: file.name,
        url,
        audioElement,
        analyser: null,
        freqData: null,
        isPlaying: false
      };
      setStatus(`Audio attached: ${file.name}. Playback starts when the tile is on the mural.`);
    }

    function setupAudioAnalyser(tile) {
      if (!tile.audio) return;
      if (!state.audioContext) {
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      const context = state.audioContext;
      const source = context.createMediaElementSource(tile.audio.audioElement);
      const analyser = context.createAnalyser();
      analyser.fftSize = 256;
      const gain = context.createGain();
      gain.gain.value = 0.6;
      source.connect(gain);
      gain.connect(analyser);
      analyser.connect(context.destination);
      tile.audio.analyser = analyser;
      tile.audio.freqData = new Uint8Array(analyser.frequencyBinCount);
    }

    function updateAudioBoard() {
      audioControlList.innerHTML = '';
      state.muralTiles
        .filter((tile) => tile.audio)
        .forEach((tile) => {
          const item = document.createElement('div');
          item.className = 'audio-item';
          const button = document.createElement('button');
          button.textContent = tile.audio.isPlaying ? 'Pause' : 'Play';
          button.addEventListener('click', async () => {
            if (!state.audioContext) return;
            await state.audioContext.resume();
            if (tile.audio.audioElement.paused) {
              tile.audio.audioElement.play();
              tile.audio.isPlaying = true;
              button.textContent = 'Pause';
            } else {
              tile.audio.audioElement.pause();
              tile.audio.isPlaying = false;
              button.textContent = 'Play';
            }
          });
          const meta = document.createElement('span');
          meta.textContent = `${tile.meta.creatorName || 'Anonymous'} · ${tile.audio.fileName}`;
          item.appendChild(button);
          item.appendChild(meta);
          audioControlList.appendChild(item);
        });
    }

    function generateLaneSample(lane) {
      return new Promise((resolve) => {
        const size = 640;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, size, size);
        const colors = [...globalPalette.colors, lane.accent];
        gradient.addColorStop(0, lightenColor(lane.accent, 0.25));
        gradient.addColorStop(1, colors[Math.floor(Math.random() * colors.length)]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        if (lane.id === 'impasto') {
          for (let i = 0; i < 70; i++) {
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = colors[i % colors.length];
            ctx.lineWidth = 14 + Math.random() * 10;
            ctx.beginPath();
            const x = Math.random() * size;
            const y = Math.random() * size;
            ctx.moveTo(x, y);
            ctx.lineTo(x + (Math.random() - 0.5) * 140, y + (Math.random() - 0.5) * 140);
            ctx.stroke();
          }
        } else if (lane.id === 'cartoon') {
          ctx.lineWidth = 10;
          ctx.strokeStyle = '#0b1120';
          for (let i = 0; i < 8; i++) {
            const radius = 50 + Math.random() * 90;
            const x = 120 + i * 60 + Math.random() * 80;
            const y = 160 + Math.sin(i) * 60 + Math.random() * 80;
            ctx.fillStyle = colors[(i + 2) % colors.length];
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }
          ctx.fillStyle = '#0b1120';
          ctx.font = 'bold 92px Space Grotesk';
          ctx.fillText('BAM!', 180, 520);
        } else if (lane.id === 'wash') {
          for (let i = 0; i < 18; i++) {
            ctx.fillStyle = colors[i % colors.length];
            ctx.globalAlpha = 0.2 + Math.random() * 0.25;
            const w = 120 + Math.random() * 180;
            const h = 60 + Math.random() * 120;
            const x = Math.random() * (size - w);
            const y = Math.random() * (size - h);
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 0.8;
          ctx.strokeStyle = 'rgba(15,23,42,0.85)';
          ctx.lineWidth = 4;
          for (let i = 0; i < 12; i++) {
            ctx.beginPath();
            const x = Math.random() * size;
            const y = Math.random() * size;
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.random() * 160, y + Math.random() * 40);
            ctx.stroke();
          }
        } else {
          for (let i = 0; i < 12; i++) {
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = colors[(i + 1) % colors.length];
            ctx.lineWidth = 6;
            const x = Math.random() * size;
            const y = Math.random() * size;
            ctx.strokeRect(x, y, 180 + Math.random() * 120, 120 + Math.random() * 90);
          }
        }
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = canvas.toDataURL('image/png');
      });
    }

    function lightenColor(hex, amount) {
      const { r, g, b } = hexToRgb(hex);
      const hsl = rgbToHsl(r, g, b);
      hsl.l = Math.min(100, hsl.l + amount * 100);
      const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
      return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
    }

    function hexToRgb(hex) {
      const normalized = hex.replace('#', '');
      const bigint = parseInt(normalized, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b),
        min = Math.min(r, g, b);
      let h, s;
      const l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
    }

    function resizeMuralCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const baseWidth = 1280;
      const baseHeight = 720;
      muralCanvas.width = baseWidth * dpr;
      muralCanvas.height = baseHeight * dpr;
      muralCanvas.style.width = '100%';
      muralCanvas.style.height = '100%';
      muralCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden && state.isPlayingTimelapse) {

        stopTimelapse();
      }
    });

    init();
        
  </script>
</body>
</html>
